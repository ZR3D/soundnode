<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Sound Node</title>
<link rel="icon" href="data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2224mm%22%20height%3D%2224mm%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cpath%20d%3D%22m11.4%200.0108c-0.364%200.0152-0.729%200.0467-1.09%200.0941-3.23%200.497-6.25%202.28-8.1%204.97-0.447%200.54-0.713%201.2-1.07%201.8%201.77-1.76%204.58-2.35%206.91-1.43%201.89%200.709%203.32%202.28%204.04%204.14a2.4%202.39%200%200%201%202.31%202.39%202.4%202.39%200%200%201-1.36%202.15c0.549%201.4%201.56%202.62%202.96%203.27%202.3%201.14%205.29%200.311%206.76-1.77%201.13-1.46%201.44-3.39%201.16-5.18-0.438-3.4-2.4-6.55-5.27-8.44-2.14-1.41-4.7-2.09-7.25-1.98z%22%20fill%3D%22%23005880%22%2F%3E%0A%20%20%3Cpath%20d%3D%22m12.6%2024c0.364-0.0152%200.729-0.0467%201.09-0.0941%203.23-0.497%206.25-2.28%208.1-4.97%200.447-0.54%200.713-1.2%201.07-1.8-1.77%201.76-4.58%202.35-6.91%201.43-1.89-0.709-3.32-2.28-4.04-4.14a2.4%202.39%200%200%201-2.31-2.39%202.4%202.39%200%200%201%201.36-2.15c-0.549-1.4-1.56-2.62-2.96-3.27-2.3-1.14-5.29-0.311-6.76%201.77-1.13%201.46-1.44%203.39-1.16%205.18%200.438%203.4%202.4%206.55%205.27%208.44%202.14%201.41%204.7%202.09%207.25%201.98z%22%20fill%3D%22%23004b6f%22%20%2F%3E%0A%3C%2Fsvg%3E">
<style>
:root {
  --color-bg: #2a3d50;
  --color-bg-lighter: #37485a;
  --color-panel-header: #3f7f9d;
  --color-panel-bg: #0f374a;
  --color-outline: #ccc;
  --beat-line: #dddddd;
  --track-bg: #303f4f;
  --color-track-0: #7CA3C6;
  --color-track-1: #c6c47c;
  --color-track-2: #80c67c;
  --color-track-3: #7cb5c6;
  --color-track-4: #c67cb1;
  --color-track-5: #7CA3C6;
  --color-track-6: #DD7972;
  --color-track-7: #8D72DD;
  --color-track-8: #C5DD72;
}
* {box-sizing: border-box; margin: 0; padding: 0;}
*html {font-size: 62.5%;}
body {font-family: 'Inter', system-ui, sans-serif; display: flex;  flex-direction: column; font-size: 12px; transition: 0.3s ease; background-color: var(--color-bg);  color: #111;}
select, input{border-radius: 4px; border:none; padding:0.33rem; background:#fff; margin-right:0.5rem; font-size: 12px;}
input{font-size: 12px;}
input[type=number]{width:3rem;}
button {border-radius: 4px; border:none; background:#54697e; color:#fff; padding:0.33rem; cursor:pointer; font-size: 12px;}
button:hover{background:#57738F;}
option:disabled{background-color:#637C9E; color:#f1f1f1;}
.main{margin-left: 1rem; transition: width 0.8s ease}
.button-row{padding: 1rem 0rem; align-items: center;}
/* --- Sound Node Graph --- */
.node-box-html{width:220px; padding-bottom:2rem; background:#6b6e72; border-radius:6px; }
.node-box-title{background:#363c4a; border-radius:6px 6px 0px 0px; padding:0.3rem; color:#fff; cursor:pointer; user-select: none;}
.selected{background:#1b495e;}
.node-box-main{background:transparent; border-radius:0px 0px 6px 6px;}
.node-box-row{background:#afafaf; margin: 2px 0px; min-height:27px;}
.node-box-row div{display: inline-block; padding:0.2rem; user-select: none;}
.node-box-label{user-select: none; width:92px;}
.node-box-input{width:88px;}
.connect-line{fill:none; stroke-width:3px; stroke:#E0C12F; stroke-linecap:round;}
.input-connect, .input-connect-blank{background:#AFBEC1; width:10px; height:10px; border-radius:6px; margin:0px 5px; cursor:pointer;}
.node-box-input input[type=number], {width:3.6rem;}
.input-connect-blank{opacity:0;}
.input-connect:hover{background:#98A6A8;}
.output-connect{background:#D3891F; width:10px; height:10px; border-radius:6px; margin:0px 5px; cursor:pointer;}
.output-connect:hover{background:#D3C11F}
.hidden, .node-box-row .hidden{display:none;}
.node-box-row select, .node-box-row input{padding:0.2rem;}
.button-icon-container {padding: 3px 0px 0px 1px;  height: 25.53px; width: 35px;}
.button-icon, .arrow-icon {fill: none; stroke: rgb(241, 241, 241); height: 18px; width: 18px;}
.arrow-icon{stroke: none; fill: #f1f1f1;}
.sound-info{background: #e3ebeecc; border-radius:4px; padding:10px;}
.sound-info-row{background:#ffffff88; margin-bottom: 3px; min-height:27px; border-radius:2px;}
.sound-info-label{display:inline-block; width:92px; padding: 0.2rem; user-select: none;}
.sound-info-input{display:inline-block; width:92px; padding: 0.2rem;}
.sound-info-input input[type=number], .sound-info-input select{width:3.6rem; padding: 0.2rem;}
/* --- Modal --- */
.modal-backdrop {position: fixed;  top: 0;  left: 0;  width: 100vw;  height: 100vh;  background: #00000060;  display: none;  align-items: center;  justify-content: center;  z-index: 1000;}
.modal {  background: #f1f1f1;  padding: 1.5rem;  border-radius: 10px;  max-width: 510px;  width: 90%;  box-shadow: 0 10px 30px #00000030;  position: relative;  color: #111111;}
.modal h2 {  margin-top: 0;}
.modal .close {  position: absolute;  top: 10px;  right: 14px;  font-size: 1.5rem;  color: #898989;  cursor: pointer;}
.modal .close:hover {  color: #000000;}
.modal-heading { font-size: 1.2rem;}
.modal-content div{ margin: 0.6rem 0rem;}
.modal-content .modal-block{display: inline-block; margin: 1rem;}
/* --- Toast --- */
.toast {z-index: 1100; position: fixed;  bottom: 0px;  left: 0px;  width: 100%;  margin: 0px;  padding: 10px 20px;  color: #ffffff;  font-size: 0.9rem;  transition: opacity 0.3s ease;  opacity: 0;  pointer-events: none;}
.toast.show {opacity: 1;  pointer-events: auto;}
.toast.success {background-color:#32B350;}
.toast.error {background-color:#B3325E;}
.toast.info {background-color:#3283B3;}
/* --- Side Panel --- */
.side-panel{
  position:fixed; right:0; top:0; min-width: 300px; max-width:300px; height:100vh; background:var(--color-panel-bg); padding:0rem; margin:0rem; color:#ffffff;
  transition: flex-basis 0.8s ease, min-width 0.8s ease, max-width 0.8s ease, padding 0.8s ease;
  z-index: 800;
 }
.side-panel-collapsed {flex: none; min-width: 0; max-width: 0; padding: 0rem 0rem; border: none; overflow: hidden;}
.side-panel .side-panel-header{padding: 0.6rem; background:var(--color-panel-header); white-space: nowrap; cursor:pointer; display:flex; align-items: center; margin-bottom: 4px;}
.side-panel-header .header-title{flex:1;}
.side-panel .panel-section{margin-top: 1rem; margin-bottom: 1.5rem;}
.side-panel-row{padding: 0rem 0.7rem; margin-bottom: 4px; }
.side-panel-collapsed .side-panel-row{overflow:hidden; white-space: nowrap;}
.side-panel .panel-header-first{margin-top: 0rem;}
.side-panel-button{position:fixed; right:300px; top:0px; width: 35px; height: 35px; background:#33596c; align-content:center; transition: right 0.8s ease; z-index:1000;}
.side-panel-button-collapsed {right:0px;}
.side-panel-button button{background: transparent;}
/* --- SVG --- */
.svg-container{overflow:auto; background:var(--color-bg-lighter); width:100%; scrollbar-color:#54697e var(--color-bg-lighter);}
.svg-container-song-sound{background:#405777;}
.svg-point{fill:#30527D; cursor:pointer;}
.svg-point:hover{fill:#E38035;}
.adsr-line{fill:none; stroke:#81b0c7; stroke-width:2px;}
.chart-side-text{text-anchor:end; user-select:none; fill:#ccc;}
.chart-bottom-text{text-anchor:middle; user-select:none; fill:#ccc;}
.adsr-graph-svg{cursor:pointer; background:#f6f6f6; border-radius:2px;}
.adsr-grid{x:60; y:40; width:361px; height:241px; fill:url(#adsrGrid)}
/* --- Soundit --- */
input[type=range]{padding:0rem; accent-color: #3d72a6; vertical-align:middle;}
/* --- Keyboard --- */
.keyboard-container {overflow-x: auto; width: 100%; white-space: nowrap; margin: 0.5rem 0rem; scrollbar-color:#54697e var(--color-bg-lighter); background:var(--color-bg-lighter);}
.keyboard{display:flex;  margin: 1rem 1rem; gap: 2px 0px; }
.key-button-major, .key-button-minor {border-radius: 0px 0px 4px 4px; background: #3D72A6; height: 90px;  min-width:33px; align-content:center; border:none;  color:#fff; cursor:pointer; white-space: pre-line; padding:0rem;  font-size: 0.74rem;}
.key-button-major{padding-top: 2.8rem; z-index:10; margin-left: 4px;}
.key-button-minor {background: #476582; height: 40px; margin-left: -15px; padding-top: 0rem; margin-top: 0rem; border: 2px solid var(--color-bg-lighter); z-index:20; border-top: 0;}
.key-button-major{margin-left: 2px;}
.lh-minor{margin-left: -16px;}
.key-button:hover{background: #577DA2;}
.key-button-minor:hover{background: #4A6D8F;}
.keyboard-container .key-selected{background: #38ADD2;}
.keyboard-container .key-weighted{color: #DADC46;}
.keyboard-container .key-weighted-da{color: #38d280;}
/* .key-button-major{background: linear-gradient(to bottom, #3D72A6 92%, #6791BB 92% 100%);}
.key-button-minor{background: linear-gradient(to bottom, #476582 90%, #6985A0 90% 100%);} */
.keyboard-container .key-selected{background: linear-gradient(to bottom, #3D72A6 92%, #38ADD2 92% 100% );}
.key-played{background: linear-gradient( to bottom, #3D72A6 92%, #6791BB 92% 100% ); border-bottom: 2px solid #ccc;}
/* --- Tracks --- */
.track-outline{stroke: var(--color-outline); stroke-width: 0.5px; rx:4; height:70px; fill:var(--track-bg);}
.track-body{height:70px; fill:url('#beatLine');}
.note-box, .note-box-virtual{fill: #c9cdd5dd; height: 20px; cursor:pointer;}
.note-box-virtual, .note-box-virtual-text{opacity: 0.5;}
.note-box:hover, .track-title-container:hover{opacity:0.8;}
.track-0 .box-color{fill: var(--color-track-0); background: var(--color-track-0);}
.track-1 .box-color{fill: var(--color-track-1); background: var(--color-track-1);}
.track-2 .box-color{fill: var(--color-track-2); background: var(--color-track-2);}
.track-3 .box-color{fill: var(--color-track-3); background: var(--color-track-3);}
.track-4 .box-color{fill: var(--color-track-4); background: var(--color-track-4);}
.track-5 .box-color{fill: var(--color-track-5); background: var(--color-track-5);}
.track-6 .box-color{fill: var(--color-track-6); background: var(--color-track-6);}
.track-7 .box-color{fill: var(--color-track-7); background: var(--color-track-7);}
.track-8 .box-color{fill: var(--color-track-8); background: var(--color-track-8);}
.track-0 .box-color{fill:url('#track-0');}
.track-1 .box-color{fill:url('#track-1');}
.track-2 .box-color{fill:url('#track-2');}
.track-3 .box-color{fill:url('#track-3');}
.track-4 .box-color{fill:url('#track-4');}
.track-5 .box-color{fill:url('#track-5');}
.track-6 .box-color{fill:url('#track-6');}
.track-7 .box-color{fill:url('#track-7');}
.track-8 .box-color{fill:url('#track-8');}
.track-1 .box-color{fill:url('#track-1');}
.track-title{padding:0.2rem 0.4rem; border-radius: 4px 0px 0px 0px; cursor:pointer;}
.track-controls{height: 70px;}
.track-controls div{user-select:none;}
.track-controls button{padding: 3px 3.5px; margin:4px 0px 0px 3px; text-align:left; user-select:none;}
.track-controls .sound-button{width: 90px; overflow:hidden; white-space: nowrap; text-overflow: ellipsis;}
.controls-container{background: var(--track-bg); height: 70px; width: 200px; padding: 0px 5px;}
.track-container{width:100%; background:var(--color-bg-lighter); overflow:hidden;} /* ; scrollbar-color:#54697e var(--color-bg-lighter); overflow:auto; */
.track-container .note-select{fill: #F0A33E; }
.track-container .note-playing{fill: #4FB066;}
.track-gain-container{padding-top: 4px;}
.loop-track{fill:#46A81C55; height:5px; cursor:pointer;}
.loop-track:hover{fill:#46A81C99;}
.loop-select{fill: #46A81Caa; height: 10px;}
.cursor-selection{fill: #00000012;}
.box-color:hover{opacity:0.9;}
.note-box-text, .note-box-virtual-text{  text-anchor: middle;  dominant-baseline:middle;  fill:#123456;  user-select: none;  pointer-events: none; font-size:11px;}
.drag-circle{fill: #7CB070; cursor:pointer;}
.drag-circle:hover{fill: #D5DD34;}
.add-circle{fill: #00000020; cursor:pointer;}
.add-circle:hover{fill: #D5DD34;}
.time-bar-hidden{fill:transparent;}
.time-bar{fill:#90B8D2;}
.time-line-circle{fill:#EA673C; cursor:pointer;}
.time-line-circle:hover{fill:#EAB33C; stroke:#EA673C; stroke-width:2px;}
.beat-line{stroke:var(--beat-line); fill:none;}
/* --- Periodic Wave --- */
.modal-content .harmonics-container div{margin: 0px 0px;}
.harmonics-container input[type=number]{width:3rem;}
.harmonics-container{margin-bottom: 10px;}
.harmonics-container div{display: inline-block; width: 3.2rem;}
.harmonics-container .harmonic-title{width: 2.2rem;}
.button-container{margin-bottom: 10px;}
.label-text{display: inline-block; width: 6rem;}
.label-text-left{display: inline-block; padding-right:7px;}
.custom-sound{background: #2d5b51;}
.greyed{opacity: 0.5;}
.greyed:hover{opacity: 0.5;}
.color-picker {-webkit-appearance: none; -moz-appearance: none; appearance: none; width: 30px; height: 33px; background-color: transparent; border: none; cursor: pointer;}
</style>
</head>
<body>
  <div id="mainCard" class="main dom-el">
  <div class="button-row">
  <select id="soundSelect" class="dom-ctrl"></select>
  <button onclick="openModal('modalAddSound')">+ Add Sound</button>
  <button onclick="showSoundDetails()">Sound Details</button>
  <select id="nodeSelect" class="dom-ctrl" placeholder="Select node.  .."></select>
  <button onclick="deleteNode()">Delete Node</button>
  <input id="soundZoomRange" oninput="changeSoundZoom()" type="range" class="slider dom-ctrl" min="50" max="200" value="100" />
  <button onclick="resetSoundZoom()">Reset Zoom</button>
  <button onclick="openSoundMasterBus()">Sound Master Bus</button>
  </div>
  <div id="svgContainer" class="svg-container dom-el">
  <svg id="graphSvg" viewbox="0 0 1873 701" class="dom-svg" width="1873" height="701" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#C4C4C4" stroke-width="0.5"/>
      </pattern>
      <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
        <rect width="100" height="100" fill="url(#smallGrid)" />
        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#C4C4C4" stroke-width="1"/>
      </pattern>
      <pattern id="adsrGrid" width="20" height="20" patternUnits="userSpaceOnUse">
        <path d="M20 0 L0 0 L0 20" fill="none" stroke="#C4C4C4" stroke-width="0.5"/>
      </pattern>
    </defs>
    <g class="grid-background">
      <rect width="100%" height="100%" fill="url(#grid)" style="opacity:0.5" />
    </g>
    <g id="soundInfo" class="dom-svg">
    </g>
    <g id="nodeBoxes" class="dom-svg"></g>
    <g id="nodeLines" class="dom-svg"></g>
    <g id="nodeInteractive" class="dom-svg"></g>
  </svg>
</div>

<div id="keyboardContainer" class="keyboard-container dom-el">
  <div id="keyboard" class="keyboard dom-el"></div>
</div>

<div class="button-row">
  <button onclick="addTrack()">+ Add Track</button>
  <button onclick="addNote()">+ Add Note After Selected</button>
  <button onclick="deleteNote()">- Remove Selected Notes</button>
  <select id="resolutionSelect" onchange="changeBarView(Number(this.value))" class="dom-ctrl">
    <option value="4">4x</option>
    <option value="8">8x</option>
    <option value="16">16x</option>
  </select>
  <label>Zoom</label>
  <input id="zoomRange" oninput="changeZoom()" type="range" class="slider dom-ctrl" min="50" max="200" value="100" />
  <input id="panLeftRange" oninput="changeZoom()" type="range" class="slider dom-ctrl" min="0" max="100" value="0" />
  <button onclick="resetZoom()">Reset Zoom</button>
  <label>Snap</label>
  <input id="snapCheckbox" onclick="toggleSnap()" type="checkbox" class="dom-ctrl" checked>
  <button onclick="trackMode('paint')">+ Paint Note</button>
  <button onclick="trackMode('select')">Select</button>
</div>

<div id="tracksContainer" class="track-container dom-el">
  <svg id="tracksSvg" class="svg-canvas dom-svg" version="1.1" viewBox="0 0 1800 300" xmlns="http://www.w3.org/2000/svg" width="1800" height="300">
      <defs id="tracksDefs" class="dom-svg">
        <pattern id="beatLineSmall" x="0" y="20" width="25" height="10" patternUnits="userSpaceOnUse" class="dom-svg">
          <path d="M0 0 L0 10" stroke-width="0.5" class="beat-line"/>
        </pattern>
        <pattern id="beatLine"  x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
          <rect x="0" y="0" width="100" height="10" fill="url(#beatLineSmall)"/>
          <path d="M0 0 L0 100" stroke-width="0.5" class="beat-line"/>
        </pattern>
      </defs>
      <g id="backgroundLayer" class="line-layer" ></g>
      <g class="chart-container" >
        <rect id="timeBar" x="0" y="0" width="1" height="100%" class="dom-svg time-bar-hidden" />
        <g id="trackContainer" class="dom-svg"></g>
      </g>
      <g>
        <rect id="selection" x="0" y="0" width="0" height="0" class="cursor-selection dom-svg" />
      </g>
      <g id='timeLine' class="dom-svg">
        <rect id="timeLine0" x="350" y="0" width="1" height="100%" class="time-bar dom-svg" />
        <rect id="timeLine1" x="450" y="0" width="1" height="100%" class="time-bar dom-svg" />
        <circle id="timeDrag0" class="time-line-circle dom-svg" cx="350" cy="5" r="4"></circle>
        <circle id="timeDrag1" class="time-line-circle dom-svg" cx="450" cy="5" r="4"></circle>
      </g>
  </svg>
</div>
</div>

<div id="sidePanelButton" class="side-panel-button dom-el">
<button id="toggleSidePanelButton" class="button-icon-container dom-btn"><svg class="button-icon" aria-label="open side panel"><use href="#side-panel"></use></svg></button>
</div>

<div id="sidePanel" class="side-panel dom-el">
<div onclick="togglePanelSection('songPanel')" class="side-panel-header panel-header-first">
  <div class="header-title">Song</div>
  <div><svg class="arrow-icon" aria-label="open side panel"><use id="songPanelIcon" href="#down-arrow"></use></svg></div>
</div>
<div id="songPanel" class="panel-section dom-el">
<div class="side-panel-row">
    <label>Volume</label>
    <input id="masterGainRange" oninput="changeMasterGain()" type="range" class="slider dom-ctrl" min="0" max="100" value="80" />
  </div>

  <div class="side-panel-row">
    <select id="songSelect" onchange="updateSong(this.value)" class="dom-ctrl"></select>
  </div>
  <div class="side-panel-row">
    <button onclick="showSongDetails()">Song Details</button>
  </div>
  <div class="side-panel-row">
    <button onclick="playCurrentSong('context')">Play Song</button>
    <input id="animationCheck" onclick="setAnimationOn(this.checked)" type="checkbox" class="dom-ctrl"><div class="label-text">Animation On</div>
  </div>

  <div class="side-panel-row">
    <button onclick="stopSound('all')">Stop Song</button>
  </div>

  <div class="side-panel-row">
    <button onclick="playCurrentSong('render')">Render Song</button>
  </div>

  <div class="side-panel-row">
    <button onclick="playCurrentSong('offline')">Render and Save Song</button>
  </div>
  <div class="side-panel-row">
    <button onclick="playRenderedBuffer(renderedBuffer)">Play Rendered Song</button>
  </div>
  <div class="side-panel-row">
    <button onclick="openMasterBus()">Song Master Bus</button>
  </div>
  <div class="side-panel-row">
    <button onclick="openModal('modalAddSong')">+ New Song</button>
  </div>
</div>
<div onclick="togglePanelSection('soundPanel')" class="side-panel-header">
  <div class="header-title">Sound</div>
  <div><svg class="arrow-icon" aria-label="open side panel"><use id="soundPanelIcon" href="#down-arrow"></use></svg></div>
</div>

<div id="soundPanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <input id="graphNodeName" type="text" class="dom-ctrl" placeholder="Select graph node to rename">
  </div>
  <div class="side-panel-row">
    <button onclick="renameGraphNode()">Rename Graph Node</button>
  </div>
</div>

<div onclick="togglePanelSection('trackPanel')" class="side-panel-header">
  <div class="header-title">Track</div>
  <div><svg class="arrow-icon" aria-label="open side panel"><use id="trackPanelIcon" href="#down-arrow"></use></svg></div>
</div>
  <div id="trackPanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <button onclick="bakeAllTracks()">Render All Tracks</button>
  </div>
  <div id="trackDownloads" class="side-panel-row dom-el"></div>
  <div id="trackPlayButtons" class="side-panel-row dom-el"></div>
</div>

<div onclick="togglePanelSection('notePanel')" class="side-panel-header">
  <div class="header-title">Note</div>
  <div><svg class="arrow-icon" aria-label="open side panel"><use id="notePanelIcon" href="#down-arrow"></use></svg></div>
</div>
<div id="notePanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <div class="label-text">Selected Notes</div>
  </div>
  <div class="side-panel-row">
    <button onclick="changeSemitone(12)">Up One Octave</button>
  </div>
  <div class="side-panel-row">
    <button onclick="changeSemitone(-12)">Down One Octave</button>
  </div>
  <div class="side-panel-row">
    <button onclick="changeSemitone(1)">Up One Semitone</button>
  </div>
  <div class="side-panel-row">
    <button onclick="changeSemitone(-1)">Down One Semitone</button>
  </div>
</div>

<div onclick="togglePanelSection('generativePanel')" class="side-panel-header">
  <div class="header-title">Guides and Generative</div>
  <div><svg class="arrow-icon" aria-label="open side panel"><use id="generativePanelIcon" href="#down-arrow"></use></svg></div>
</div>
<div id="generativePanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <div class="label-text">Last Note</div>
    <input id="lastKeyPlayedInput" oninput="changeLastPlayed(this.value)" type="text" style="width:3rem" value="a4" class="dom-ctrl">
  </div>
  <div class="side-panel-row">
    <div class="label-text">Highlight Last</div>
    <button onclick="highlightScales()">Scale</button>
    <button onclick="highlightChord()">Chord</button>
    <button onclick="highlightClear()">Clear</button>
  </div>
  <div class="side-panel-row">
    <div class="label-text">Scales</div>
    <select id="scalesSelect" class="dom-ctrl"></select>
  </div>
  <div class="side-panel-row">
    <div class="label-text">Chords</div>
    <select id="chordsSelect" class="dom-ctrl"></select>
  </div>
  <div class="side-panel-row">
    <div class="label-text">Chord Presets</div>
    <select onchange="chordPresetChange()" id="chordPresets" class="dom-ctrl">
      <option></option>
      <option>c major</option>
      <option>g major</option>
      <option>d major</option>
      <option>a major</option>
      <option>e major</option>
      <option>a minor</option>
      <option>e minor</option>
      <option>b minor</option>
      <option>f# minor</option>
      <option>c# minor</option>
    </select>
    <input id="octaveNumberInput" oninput="chordPresetChange()" type="number" value="3" min="1" max="7" class="dom-ctrl">
  </div>

  <div class="side-panel-row">
    <button onclick="openPhraseModal()">Build Phrase</button>
  </div>

  <div class="side-panel-row">
    <button onclick="openDrumModal()">+ Add Drum Track</button>
  </div>
 </div>

  <div onclick="togglePanelSection('importPanel')"class="side-panel-header">
    <div class="header-title">Import Export</div>
    <div><svg class="arrow-icon" aria-label="open side panel"><use id="importPanelIcon" href="#down-arrow"></use></svg></div>
  </div>
  <div id="importPanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <button id="exportDataButton">Export Data</button>
    <button id="importDataButton">Import Data</button>
  </div>
  <div class="side-panel-row">
    <button onclick="exportSong()">Export Song Data</button>
    <button onclick="importSong()">Import Song Data</button>
  </div>
  <div class="side-panel-row">
    <button onclick="exportSound()">Export Sound Data</button>
    <button onclick="importSound()">Import Sound Data</button>
    <input id="hiddenFileInput" type="file" class="dom-ctrl hidden"/>
  </div>

  </div>

  <div onclick="togglePanelSection('experimentalPanel')" class="side-panel-header">
    <div class="header-title">Experimental</div>
    <div><svg class="arrow-icon" aria-label="open side panel"><use id="experimentalPanelIcon" href="#down-arrow"></use></svg></div>
  </div>
  <div id="experimentalPanel" class="panel-section dom-el">
  <div class="side-panel-row">
    <button onclick="playLoopButton()">Play Loop</button>
    <button onclick="playSliceButton()">Play Slice</button>

    <button onclick="changeLightDark('dark')">Dark Mode</button>
    <button onclick="changeLightDark('light')">Light Mode</button>
  </div>
</div>
</div>
<div id="toast" class="toast hidden dom-el"></div>
<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <span class="close" onclick="closeModal()" id="closeModalButton">&times;</span>
    <div id="modalContent" class="modal-content">
    </div>
    <div id="modalAddSound" class="modal-content">
      <h2>Add Sound</h2>
      <div>
        <input id="addNewSoundInput" class="dom-ctrl" type="text" placeholder="Type sound title here...">
        <button onclick="addNewSound()">Add New Sound</button>
        <button onclick="cloneSound()">Save as New</button>
      </div>

    </div>
    <div id="modalSaveSettings" class="modal-content">
      <h2>Save Setting</h2>
      <div>
        <input id="saveSettingsInput" class="dom-ctrl" type="text" placeholder="Type settings title here...">
        <button onclick="saveSettings()">Save Setting</button>
      </div>
    </div>
    <div id="modalAdsr" class="modal-content">
      <h2>ADSR</h2>
      <div>
    <div class="svg-panel">
        <svg id="adsrSvg" class="svg-canvas dom-svg" version="1.1" viewBox="0 0 460 320" xmlns="http://www.w3.org/2000/svg" width="460px" height="320px">
            <g id="backgroundLayer" class="line-layer"></g>
            <g class="chart-container" >
              <rect class="adsr-grid" />
               <text id="adsrTime" class="chart-bottom-text dom-svg" x="220" y="20" style="fill:#ccc;">ADSR</text>
               <text id="adsrAmpMax" class="chart-side-text dom-svg" x="50" y="45" >1</text>
               <text class="chart-side-text" x="50" y="165">Amp</text>
               <text id="adsrAmpMin" class="chart-side-text dom-svg" x="50" y="285">0</text>
               <text class="chart-bottom-text" x="60" y="300">0</text>
               <text class="chart-bottom-text" x="240" y="300">Time</text>
               <text class="chart-bottom-text" x="420" y="300">1</text>
              <g id="graphLayer" class="line-layer dom-svg"></g>
              <g id="lineLayer" class="line-layer dom-svg">
              <path id="adsrLine" d="" class="adsr-line dom-svg"></path>
              </g>
              <g id="pointLayer" class="point-layer dom-svg"></g>
            </g>
        </svg>
      </div>
      <div>
        <button onclick="adsrMode('move')">Move Points</button>
        <button onclick="adsrMode('add')">+ Add Point</button>
        <button onclick="adsrMode('remove')">- Remove Point</button>
      </div>
      <div>
      <div class="label-text-left">Amplitude</div><input type="number" id="adsrAmplitudeText" class="dom-ctrl" step="0.1">
      <div class="label-text-left">Time</div><input type="number" id="adsrTimeText" class="dom-ctrl" step="0.1">
      <div class="label-text-left">Point</div><select id="adsrPointSelect" class="dom-ctrl">
        <option value="point">point</option>
        <option value="curve-point">curve-point</option>
      </select>
      <div class="label-text-left">Line</div><select id="adsrLineSelect" class="dom-ctrl">
        <option value="line">line</option>
        <option value="curve">curve</option>
        <option value="set">set</option>
      </select>
      </div>
    </div>
  </div>
  <div id="modalTrackOptions" class="modal-content">
  <h2>Track Options</h2>
  <div id="changeTrackSoundContent">
  </div>
    <div>
      <div class="label-text">Track Name</div>
      <input id="renameTrackInput" class="dom-ctrl" type="text" placeholder="Type track title here...">
      <button onclick="renameTrack()">Rename Track</button>
    </div>
    <div>
      <div class="label-text">Track Color</div>
      <input id="trackColorInput" type="color" class="color-picker dom-ctrl" oninput="changeTrackColor(this.value)">
    </div>
    <div>
      <div class="label-text">Delete Track</div>
      <button onclick="openModal('modalDeleteTrack')">Delete Track</button>
    </div>
    <div>
      <div class="label-text">Move Track</div>
      <button onclick="moveTrack('up')">Up</button>
      <button onclick="moveTrack('down')">Down</button>
    </div>
    <div>
      <div id="trackSoundDiv" class="dom-el label-text"></div>
      <select id="trackSoundSelect" class="dom-ctrl"></select>
      <button onclick="changeTrackSound()">Change Track Sound</button>
    </div>
    <div>
      <div class="label-text">Loop</div>
      <button onclick="openModal('modalLoopSettings')">Loop Settings</button>
    </div>
  <div>
    <div class="label-text"></div>
    <button onclick="updateTrackSound()">Update</button>
    <button onclick="closeModal()">Cancel</button>
  </div>
</div>
      <div id="modalLoopSettings" class="modal-content">
        <h2>Track Loop Settings</h2>
        <div>
          <div><div class="label-text">Loop On</div><input id="loopCheck" type="checkbox" class="dom-ctrl"></div>
          <div><div class="label-text">Start</div><input id="loopStartInput" class="input-small dom-ctrl" type="Number" value="0" /></div>
          <div><div class="label-text">End</div><input id="loopEndInput" class="input-small dom-ctrl" type="Number" value="0" /></div>
          <div><div class="label-text">Quantity</div><input id="loopQtyInput" class="input-small dom-ctrl" type="Number" value="0" /><button onclick="fillTrack()">Fill Track</button></div>
        </div>
        <div>
          <button onclick="renderLoopToTrack()">Render Loop To Track</button>
        </div>
        <div>
          <button onclick="closeModal()">Close</button>
        </div>
      </div>
      <div id="modalDeleteTrack" class="modal-content">
        <h2>Delete Track</h2>
        <div class="modal-text">Are you sure?</div>
        <div>
          <button onclick="deleteTrack()">Delete</button>
          <button onclick="closeModal()">Cancel</button>
        </div>
      </div>
      <div id="modalDeleteSound" class="modal-content">
        <h2>Delete Sound</h2>
        <div class="modal-text">Are you sure?</div>
        <div>
          <button onclick="deleteSound()">Delete</button>
          <button onclick="closeModal()">Cancel</button>
        </div>
      </div>
      <div id="modalDeleteSong" class="modal-content">
        <h2>Delete Song</h2>
        <div class="modal-text">Are you sure?</div>
        <div>
          <button onclick="deleteSong()">Delete</button>
          <button onclick="closeModal()">Cancel</button>
        </div>
      </div>
      <div id="modalPeriodicWave" class="modal-content">
        <h2>Periodic Wave</h2>
        <div class="button-container">
          <button onclick="startTestSound()">Test Sound</button>
          <select id="periodicWaveSelect" class="inp" onchange="usePeriodicPreset(this.value)"></select>
      </div>

  <div id="harmonicsHeader" class="harmonics-container">
    <div>&nbsp;</div><div>H1</div><div>H2</div><div>H3</div><div>H4</div><div>H5</div><div>H6</div><div>H7</div><div>H8</div>
  </div>
  <div id="realHarmonics" class="harmonics-container"></div>
  <div id="imagHarmonics" class="harmonics-container"></div>

  <svg id="periodicSvg" class="svg-canvas" version="1.1" viewBox="0 0 450 300" xmlns="http://www.w3.org/2000/svg" width="450px" height="300px">
      <g id="backgroundLayerx" class="line-layer"></g>
      <g class="chart-container">
        <text class="chart-bottom-text" x="180" y="25" style="fill:#ccc;">Periodic Wave</text>
        <g id="graphLayerWaveshaper" class="line-layer"><path id="null" d="M50 50 L410 50" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="55" style="fill:#ccc;">1</text><path id="null" d="M50 70 L410 70" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="75" style="fill:#ccc;">0.8</text><path id="null" d="M50 90 L410 90" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="95" style="fill:#ccc;">0.6</text><path id="null" d="M50 110 L410 110" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="115" style="fill:#ccc;">0.4</text><path id="null" d="M50 130 L410 130" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="135" style="fill:#ccc;">0.2</text><path id="null" d="M50 150 L410 150" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="155" style="fill:#ccc;">0</text><path id="null" d="M50 170 L410 170" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="175" style="fill:#ccc;">-0.2</text><path id="null" d="M50 190 L410 190" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="195" style="fill:#ccc;">-0.4</text><path id="null" d="M50 210 L410 210" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="215" style="fill:#ccc;">-0.6</text><path id="null" d="M50 230 L410 230" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="235" style="fill:#ccc;">-0.8</text><path id="null" d="M50 250 L410 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><text class="chart-side-text" x="40" y="255" style="fill:#ccc;">-1</text><path id="null" d="M70 50 L70 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M91.25 50 L91.25 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M112.5 50 L112.5 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M133.75 50 L133.75 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M155 50 L155 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M176.25 50 L176.25 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M197.5 50 L197.5 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M218.75 50 L218.75 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M240 50 L240 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M261.25 50 L261.25 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M282.5 50 L282.5 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M303.75 50 L303.75 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M325 50 L325 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M346.25 50 L346.25 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M367.5 50 L367.5 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M388.75 50 L388.75 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path><path id="null" d="M410 50 L410 250" style="fill:none; stroke:#ccc; stroke-width:0.5;"></path></g>
        <g id="lineLayerx" class="line-layer">
        <path id="periodicWavePath" d="" stroke="#2792BD" fill="none" stroke-width="1"></path>
        </g>
        <g id="pointLayerx" class="point-layer"></g>
        <g id="outputLayerx" class="point-layer"></g>
      </g>
  </svg>
</div>

  <div id="modalAddSong" class="modal-content">
    <h2>Add New Song</h2>
    <div>
      <input type="text" id="newSongText" class="dom-ctrl" placeholder='Type song name...'>
      <button onclick="addNewSong()" id="addNewSongButton" >Create</button>
    </div>
  </div>

  <div id="modalSave" class="modal-content">
    <h2>Save Data Now?</h2>
    <div>
      <div id="lastSavedText" class="dom-el"></div>
      <button onclick="exportAllData()">Save Data Now</button>
    </div>
  </div>

  <div id="modalSoundDetails" class="modal-content">
    <h2>Sound Details</h2>
    <div>
      <div class="label-text">Title</div>
      <input id="soundTitleInput" class="dom-ctrl" type="text" placeholder="Type sound title here..." />
      <button onclick="changeSoundTitle()" class="dom-btn">Change Sound Title</button>
    </div>
    <div>
      <div class="label-text">Overwrite</div>
      <select id="soundSelectAbove" class="dom-ctrl"></select>
    </div>
    <div>
    <div class="label-text"></div>
      <button onclick="overwriteSound()">Overwrite Sound Below with Sound Above</button>
    </div>
    <div>
      <div class="label-text"></div>
      <select id="soundSelectBelow" class="dom-ctrl"></select>
    </div>
    <div>
      <div class="label-text">Delete</div>
      <button onclick="openModal('modalDeleteSound')">Delete Sound</button>
    </div>
  </div>

  <div id="modalBuildPhrase" class="modal-content">
    <h2>Build Phrase</h2>
    <div>
      <div class="label-text">Root Note</div><select id="rootNoteSelect" class="dom-ctrl"></select>
    </div>
    <div>
      <div class="label-text">Scale</div><select id="phraseScalesSelect" class="dom-ctrl"></select>
    </div>
    <div>
      <div class="label-text">Phrase Length in Bars</div><input id="barLenInput" class="input-small dom-ctrl" type="Number" value="2" />
    </div>
    <div>
      <div class="label-text">Notes per Phrase</div><input id="noteQtyInput" class="input-small dom-ctrl" type="Number" value="5" />
    </div>
    <div>
      <div class="label-text">Number of Phrases</div><input id="phraseQtyInput" class="input-small dom-ctrl" type="Number" value="3" />
    </div>
    <div>
      <button onclick="buildPhrase()">Build Phrase</button>
      <button onclick="playPhraseArrangement()">Play Phrases</button>
      <button onclick="createPhraseTrack()">Create Track with Phrases</button>
    </div>
  </div>

  <div id="modalAddDrums" class="modal-content">
    <h2>Add Drum Track</h2>
    <div>
      <div class="label-text">Select Genre</div>
      <select id="drumGenreSelect" class="dom-ctrl">
        <option>rock</option> <!-- algorythmic generated --->
        <option>funk</option>
        <option>house</option>
        <option>breakbeat</option>
        <option>funk-grove</option> <!-- hyphenated are custom --->
        <option>rock-grove</option>
        <option>breakbeat-jungle</option>
      </select>
    </div>
    <div>
      <div class="label-text">Add</div><button onclick="createDrumTracks()">+ Drum Tracks</button>
    </div>
  </div>

  <div id="modalSongDetails" class="modal-content">
    <h2>Song Details</h2>
    <div>
      <div class="label-text">Song Title</div><input id="songTitleInput" class="dom-ctrl" type="text" placeholder="Type song title here..." />
      <button onclick="changeSongTitle()" class="dom-btn">Change Song Title</button>
    </div>
    <div>
      <div class="label-text">Live Quality</div>
      <select id="sampleRateSelect">
        <option value="48000">Very High</option>
        <option value="44100">High</option>
        <option value="32000">Medium</option>
        <option value="22050">Low</option>
      </select>
    </div>
    <div>
      <div class="label-text">Tempo</div>
      <input id="tempoInput" class="input-small" type="Number" value="105" />
    </div>
    <div>
    <button onclick="openModal('modalDeleteSong')">Delete Song</button>
    </div>
  </div>

  <div id="modalRendering" class="modal-content">
    <h2>Rendering</h2>
    <div style="display: flex;
  justify-content: center;">
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 24 24" width="120" height="120">
        <style type="text/css">
        .st0{fill:#fff;}
        </style>
       <g stroke-miterlimit="20" class="st0">
        <path d="m12 1.61-12 20.8h1.66a0.692 0.692 0 0 0 0.599-0.346l9.64-16.7a0.116 0.116 0 0 1 0.201 0l9.64 16.7a0.692 0.692 0 0 0 0.598 0.346h1.66z" stroke-width="2.66"/>
        <path d="m12 10.7a1.32 1.32 0 0 0-1.32 1.32 1.32 1.32 0 0 0 1.32 1.32 1.32 1.32 0 0 0 1.32-1.32 1.32 1.32 0 0 0-1.32-1.32z" stroke-width="2.69"/>
        <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="360 12 12" to="0 12 12" dur="1s" additive="sum" repeatCount="indefinite" />
       </g>
      </svg>
    </div>
  </div>
  <!--next -->
  </div>
</div>

<a href="" id="trackDownloadButton" class="hidden dom-ctrl"></a>

<script>
// --- Global Declarations ---
const dom = {svg:{},ctrl:{},el:{},btn:{},notes:{},};
const svgns = 'http://www.w3.org/2000/svg';
let nodeData = {
  songs:[],
  sounds:[],
  currentSongId:null,
  currentSoundId:null,
  ctx:null,
  now:0,
  osc:null,
  mode:'context',
  offlineDuration:0,
  masterGain:0.8,
  animationOn:false,
  sidePanelOpen:true,
  sidePanelHidden:[],
  snap:true,
  lastSaved:'2025-12-01',
};
const sessionData = {currentNodeBox:null, currentNodeData:null, outputConnect:null};
const select = {drag:false, start:{x:0, y:0}, end:{x:0, y:0}, width:0, height:0};
let selectedNotes = [];
const selNote = {drag:false, index:null, pointList:null, notes:{},};
const box = {drag:false, dragDistance:{x:0, y:0}, selectedData:null};
const line = {drag:false, start:{x:0, y:0}, end:{x:0, y:0}};
const timeLine = {drag:false, left:{x:0}, right:{x:0}, dragObj:null, snap:{width:25, distance:6}};
const loopBox = {drag:false, info:null, type:null};
const adsr = {drag:false, index:null, pointList:null, mode:'move'}; //start:{x:0, y:0}
let connectPoints = [];  //{id:null, pos:{x:0, y:0}, param:, io:'out'}
let currentSound, letterTimeout, toastTimeout;
let graphNodes = {};
let masterBusNodes = {};
let masterConnect = null;
let graphNodesMix = {};
let keyLastPlayed = 'a4';
const keyboard = {recording:false, trackId:null, arrangement:null, start:0}
let whiteNoiseBuffer = null;
const reverb = {buffer:null, impulse:'hall', duration:2, decay:2, tone:8000, preDelay:0.03};
let tempo = 105;
let renderedBuffer = null;
let renderedBufferTracks = [];
let renderSoundReady = false;
let beatDuration = beatFromTempo(tempo);
const noteList = {'a0':27.5,'a#0':29.14,'b0':30.87,'c1':32.7,'c#1':34.65,'d1':36.71,'d#1':38.89,'e1':41.2,'f1':43.65,'f#1':46.25,'g1':49,'g#1':51.91,'a1':55,'a#1':58.27,'b1':61.74,'c2':65.41,'c#2':69.3,'d2':73.42,'d#2':77.78,'e2':82.41,'f2':87.31,'f#2':92.5,'g2':98,'g#2':103.83,'a2':110,'a#2':116.54,'b2':123.47,'c3':130.81,'c#3':138.59,'d3':146.83,'d#3':155.56,'e3':164.81,'f3':174.61,'f#3':185,'g3':196,'g#3':207.65,'a3':220,'a#3':233.08,'b3':246.94,'c4':261.63,'c#4':277.18,'d4':293.66,'d#4':311.13,'e4':329.63,'f4':349.23,'f#4':369.99,'g4':392,'g#4':415.3,'a4':440,'a#4':466.16,'b4':493.88,'c5':523.25,'c#5':554.37,'d5':587.33,'d#5':622.25,'e5':659.25,'f5':698.46,'f#5':739.99,'g5':783.99,'g#5':830.61,'a5':880,'a#5':932.33,'b5':987.77,'c6':1046.5,'c#6':1108.73,'d6':1174.66,'d#6':1244.51,'e6':1318.51,'f6':1396.91,'f#6':1479.98,'g6':1567.98,'g#6':1661.22,'a6':1760,'a#6':1864.66,'b6':1975.53,'c7':2093,'c#7':2217.46,'d7':2349.32,'d#7':2489.02,'e7':2637.02,'f7':2793.83,'f#7':2959.96,'g7':3135.96,'g#7':3322.44,'a7':3520,'a#7':3729.31,'b7':3951.07,'c8':4186.01};
const noteListKeys = Object.keys(noteList);
const lookupFlat = {a:'b',c:'d',d:'e',f:'g',g:'a'}
const nodeZoom = {zoom:100, panUp:0, panLeft:0, width:0, height:0};
const trackColors = ['#7CA3C6','#c6c47c','#80c67c','#7cb5c6','#c67cb1','#7CA3C6','#DD7972','#8D72DD','#C5DD72'];
let trackIndex = null;
let currentSong = null;
let currentTrack = null;
let currentNote = null;
let currentNoteBox = null;
let masterCompressor, masterGain;
let phraseArrangement = null;
const activeKeys = new Set();

const adsrDisplay = {
  pad:{x:60,y:40},
  dimensions:{x:360, y:240},
  points:[
  {time:0, amp:0.001 ,point:'point', line:'line'},
  {time:0.17, amp:0.9 ,point:'point', line:'line'},
  {time:0.3, amp:0.42 ,point:'point', line:'line'},
  {time:0.74, amp:0.42 ,point:'point', line:'line'},
  {time:0.95, amp:0.001 ,point:'point', line:'line'}
  ],
};

const adsrPresets = {
  standard:[{time:0,amp:0.001},{time:0.17,amp:0.9},{time:0.3,amp:0.42},{time:0.74,amp:0.42},{time:1,amp:0.001}],
  percussive:[{time:0,amp:0.001},{time:0.02,amp:1.0},{time:0.07,amp:0.0},{time:1,amp:0.001}],
  softPad:[{time:0,amp:0.001},{time:0.3,amp:0.8},{time:0.5,amp:0.7},{time:1,amp:0.001}],
  punchyBass:[{time:0,amp:1.0},{time:0.1,amp:0.5},{time:0.6,amp:0.5},{time:1,amp:0.001}],
  organDrone:[{time:0,amp:1.0},{time:0.99,amp:1.0},{time:1,amp:0.001}],
  reverseSwell:[{time:0,amp:0.001},{time:0.5,amp:0.6},{time:0.8,amp:0.2},{time:1,amp:0.001}],
  bowed:[{time:0,amp:0.001},{time:0.15,amp:0.7},{time:0.5,amp:0.5},{time:1,amp:0.001}],
  gatedPluck:[{time:0,amp:1.0},{time:0.05,amp:0.0},{time:1,amp:0.001}],
};

const modalSynthesisRatios = {
  churchBell:[ { ratio: 1.00, decay: 3.5 }, { ratio: 2.01, decay: 4.0 }, { ratio: 2.40, decay: 3.2 }, { ratio: 3.00, decay: 2.8 }, { ratio: 3.99, decay: 2.4 }, { ratio: 5.43, decay: 1.8 }, { ratio: 6.80, decay: 1.2 },],
  crystalBowl:[{ ratio: 1.00, decay: 10.0 }, { ratio: 2.01, decay: 8.0 }, { ratio: 2.99, decay: 7.0 }, { ratio: 4.02, decay: 6.0 }, { ratio: 5.01, decay: 5.0 }, { ratio: 6.00, decay: 4.0 },],
  drum:[ { ratio: 1.00, decay: 1.2 }, { ratio: 1.59, decay: 0.9 }, { ratio: 2.14, decay: 0.8 }, { ratio: 2.30, decay: 0.7 }, { ratio: 2.65, decay: 0.6 }, { ratio: 2.92, decay: 0.55 }, { ratio: 3.16, decay: 0.50 },],
  singingBowl:[ { ratio: 1.00, decay: 6.0 }, { ratio: 2.30, decay: 5.5 }, { ratio: 2.95, decay: 5.0 }, { ratio: 3.96, decay: 4.8 }, { ratio: 5.16, decay: 4.0 }, { ratio: 6.46, decay: 3.0 }, { ratio: 8.30, decay: 2.0 },],
  tibetanCymbal:[{ ratio: 1.00, decay: 6.0 }, { ratio: 1.12, decay: 5.5 }, { ratio: 1.98, decay: 5.0 }, { ratio: 2.13, decay: 4.8 }, { ratio: 2.94, decay: 4.0 }, { ratio: 3.08, decay: 3.8 }, { ratio: 4.10, decay: 3.0 }, { ratio: 5.25, decay: 2.2 },],
  tunedPipe: [ { ratio: 1.00, decay: 5.0 }, { ratio: 1.98, decay: 4.0 }, { ratio: 3.00, decay: 3.5 }, { ratio: 3.98, decay: 3.0 }, { ratio: 5.03, decay: 2.5 }, { ratio: 6.01, decay: 2.0 },],
  woodenBar: [ { ratio: 1.00, decay: 1.2 }, { ratio: 3.92, decay: 0.9 }, { ratio: 10.50, decay: 0.6 }, { ratio: 21.20, decay: 0.4 }, ],
}

// -- Helper Functions ---
function generateId() {
  return Math.random().toString(36).substr(2, 9);
}

function dateDifferenceInDays(dateStr1,dateStr2){
  const date1 = new Date(dateStr1);
  const date2 = new Date(dateStr2);
  const diffTime = Math.abs(date2 - date1);
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
}

function setSidePanel(toggle){
  // Toggle or set
  if(toggle) nodeData.sidePanelOpen = !nodeData.sidePanelOpen;
  let width = window.screen.width -40;
  if(nodeData.sidePanelOpen){
    dom.el.sidePanel.classList.remove('side-panel-collapsed');
    dom.el.sidePanelButton.classList.remove('side-panel-button-collapsed');
    width -= 300;
  }else{
    dom.el.sidePanel.classList.add('side-panel-collapsed');
    dom.el.sidePanelButton.classList.add('side-panel-button-collapsed');
  }

  //dom.el.svgContainer.style.width = width + 'px';
  //dom.el.keyboardContainer.style.width = width + 'px';
  //dom.el.tracksContainer.style.width = width + 'px';
  dom.el.mainCard.style.width = width + 'px';

  saveNodeitData();
}

function getCssValue(prop){
  const root = document.querySelector(':root');
  return getComputedStyle(root).getPropertyValue(prop);
}

function setCssValue(prop, value){
  const root = document.querySelector(':root');
  root.style.setProperty(prop, value);
}

function changeLightDark(setting){
  if(setting === 'light'){
    setCssValue('--color-bg','#8aaab8');
    setCssValue('--color-bg-lighter','#f1f1f1');
    setCssValue('--color-panel-header','#8fa5af');
    setCssValue('--color-panel-bg','#b0bec8');
    setCssValue('--beat-line','#333');
    setCssValue('--track-bg','#fafafa');
    setCssValue('--color-outline','#d3d3d3');
  }else{ //dark
    setCssValue('--color-bg','#2a3d50');
    setCssValue('--color-bg-lighter','#37485a');
    setCssValue('--color-panel-header','#3f7f9d');
    setCssValue('--color-panel-bg','#0f374a');
    setCssValue('--beat-line','#ddd');
    setCssValue('--track-bg','#303f4f');
    setCssValue('--color-outline','#8e8e8e');
  }
}

function togglePanelSection(section){
  const sectionClassList = dom.el[section].classList;
  let icon = 'down-arrow';
  if(sectionClassList.contains('hidden')){
    sectionClassList.remove('hidden');
    nodeData.sidePanelHidden = nodeData.sidePanelHidden.filter(i => i !== section);
  }else{
    sectionClassList.add('hidden');
    nodeData.sidePanelHidden.push(section);
    icon = 'up-arrow'
  }
  document.getElementById(section + 'Icon').setAttribute('href', '#' + icon);
  saveNodeitData();
}

function setPanelSection(){
  nodeData.sidePanelHidden.forEach(section => {
    dom.el[section].classList.add('hidden');
    document.getElementById(section + 'Icon').setAttribute('href', '#up-arrow');
  })
}

function saveAndRender(){
  saveNodeitData();
  renderSound();
  renderTracks();
}

function niceNum(num, decimalPlaces=3){
    const numType = typeof num
    if(numType == "string") num = Number(num);
    if(numType == "undefined" || num == null) num = 0;
    num = (Number.isInteger(num))? Number(num):Number(num.toFixed(decimalPlaces));
    return parseFloat(num); //removes trailing zeros
}

function formatDate(date) { //toLocalDateString
  date = date || new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function whiteNoise(){
  let noiseBuffer;
  if(!whiteNoiseBuffer){
    // make 1 second worth of white noise
    noiseBuffer = nodeData.ctx.createBuffer(1, nodeData.ctx.sampleRate, nodeData.ctx.sampleRate);
    const noiseBufferOutput = noiseBuffer.getChannelData(0);
    for (var i = 0; i < nodeData.ctx.sampleRate; i++){
        noiseBufferOutput[i] = Math.random() * 2 - 1; //between -1 and +1
    }
    whiteNoiseBuffer = noiseBuffer;
  }
  return whiteNoiseBuffer;
}

// Procedural impulse response generator with room presets
function createInternalImpulse(duration = 2, decay = 2,tone = 8000, preDelay = 0.03) {
  const rate = nodeData.ctx.sampleRate;
  const length = Math.floor(rate * duration);
  const impulse = nodeData.ctx.createBuffer(2, length, rate);

  // Low-pass smoothing constant (for tone shaping)
  const RC = 1.0 / (2 * Math.PI * tone);
  const dt = 1.0 / rate;
  const alpha = dt / (RC + dt);

  for (let c = 0; c < 2; c++) {
    const ch = impulse.getChannelData(c);
    const channelDecay = decay * (0.9 + Math.random() * 0.2);
    const preSamples = Math.floor(rate * preDelay);
    let last = 0;

    for (let i = 0; i < length; i++) {
      let white = 0;
      if (i >= preSamples) {
        const t = (i - preSamples) / (length - preSamples);
        white = (Math.random() * 2 - 1) * Math.pow(1 - t, channelDecay);
      }

      // Simple low-pass filter to darken over time
      last = last + alpha * (white - last);
      ch[i] = last;
    }
  }
  return impulse;
}

const impulseSettings = {
  room: {duration: 0.8, decay: 1.5, tone: 6000, preDelay: 0.01 },
  plate: {duration: 2, decay: 2.5, tone: 10000, preDelay: 0.0 },
  hall: {duration: 3, decay: 3, tone: 7000, preDelay: 0.04 },
  cathedral: {duration: 6, decay: 4, tone: 9000, preDelay: 0.08 },
  spring: {duration: 1.5, decay: 2.8, tone: 5000, preDelay: 0.02 }
}

function updateConvolver(inputNode, parameter, value){
  //console.log(inputNode, parameter.param, value);
  if(parameter.param==='impulse'){
    const settings = impulseSettings[parameter.value];
    if(settings){
      inputNode.parameters.duration.value = settings.duration;
      inputNode.parameters.decay.value = settings.decay
      inputNode.parameters.tone.value = settings.tone
      inputNode.parameters.preDelay.value = settings.preDelay
      renderSound();
    }
  }
}

function updateAdsr(inputNode, parameter, value){
  if(parameter.param==='presets'){
    const points = cloneObject(adsrPresets[value]);
    const pointList = [];
    points.forEach(point => {
      point.point = 'point';
      point.line = 'line';
      pointList.push(point);
    });
    inputNode.parameters.points.value = pointList;
    saveNodeitData();
    renderSound();
  }
}

function updateModalsynthesis(inputNode, parameter, value){
  if(parameter.param==='modeName'){
    inputNode.parameters.modeData.value = modalSynthesisRatios[value];
    console.log('modeData', modalSynthesisRatios[value])
  }
}

function normToAmpTime(norm, ampMin=0, ampMax=1) {
  let percentx =  niceNum((norm.x - adsrDisplay.pad.x) / adsrDisplay.dimensions.x);
  let percenty = niceNum(1-((norm.y - adsrDisplay.pad.y) / adsrDisplay.dimensions.y));
  return {time:percentx, amp:percenty}
}

function timeAmpToNorm(timeAmp, ampMin=0, ampMax=1) {
  let x =  niceNum( adsrDisplay.pad.x + (timeAmp.time * adsrDisplay.dimensions.x));
  let y =  niceNum(adsrDisplay.pad.y + ((1-timeAmp.amp) * adsrDisplay.dimensions.y));
  return {x,y}
}

// --- Constructor Functions ---
function Connector(id, position, parameter, io, ext){
  this.id = id;
  this.position = position;
  this.parameter = parameter;
  this.io = io;
  this.ext = ext || null;
}

function Sound(title, nodes, settings, id){
  this.title = title || `sound-${generateId()}`;
  this.nodes = nodes || [];
  this.settings = settings || [];
  this.id = id || generateId();
  this.defaltNote = 'a4';
  this.minDuration = 0;
  this.maxDuration = 0;
  this.location = 'sound';
  this.zoom = 1;
  this.isMasterBus = false;
}

// --- Factory pattern ---
function createNode({ title, type, parameters = [], position = {x:0,y:0}, connections = []}) {
  return {
    id: generateId(),
    title,
    type,
    position,
    connections,
    parameters,
  };
}

function createUniqueNode(data){
  const node = createNode(data);
  return cloneObject(node);
}

const nodeLibrary = {
  'oscillator': {
    title:'Oscillator',
    type:'oscillator',
    custom:false,
    parameters: {
      type: {value:'sine',param:'type',label:'Type',ext:''},
      frequency: {value:440,param:'frequency',label:'Frequency',ext:''},
      detune: {value:0,param:'detune',label:'Detune',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'cosinewave': {
    title:'Cosine Wave',
    type:'cosinewave',
    custom:true,
    parameters: {
      type: {value:'sine',param:'type',label:'Type',ext:'', io:''},
      useNoteFrequency: {value:false,param:'useNoteFrequency',label:'Use Note Freq',ext:'', io:''},
      frequency: {value:440,param:'frequency',label:'Frequency',ext:'', io:'i'},
      detune: {value:0,param:'detune',label:'Detune',ext:'', io:'i'},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'gain': {
    title:'Gain',
    type:'gain',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''},
      gain: {value:0.5,param:'gain',label:'Gain',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'destination': {
    title:'Destination',
    type:'destination',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''}
    }
  },
  'allnodes': {
    title:'All Nodes',
    type:'allnodes',
    custom:true,
    parameters: {
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'adsr': {
    title:'ADSR',
    type:'adsr',
    custom:true,
    parameters: {
      presets:{value:'standard',param:'presets',label:'Presets',ext:'', io:''},
      points: {
        value:[
        {time:0, amp:0.001 ,point:'point', line:'line'},
        {time:0.17, amp:0.9 ,point:'point', line:'line'},
        {time:0.3, amp:0.42 ,point:'point', line:'line'},
        {time:0.74, amp:0.42 ,point:'point', line:'line'},
        {time:1, amp:0.001 ,point:'point', line:'line'},
      ], param:'points', label:'ADSR Points',ext:'', display:'none'},
      ampMin: {value:0, param:'ampMin', label:'Amp Min', ext:''},
      ampMax: {value:1, param:'ampMax', label:'Amp Max', ext:''},
      output: {value:'io', param:'output', label:'Output', ext:'', io:'o'},
    }
  },
  'lfo': {
    title:'LFO',
    type:'lfo',
    custom:true,
    parameters: {
      type: {value:'sine',param:'type',label:'Type',ext:'oscillator'},
      frequency: {value:10,param:'frequency',label:'Frequency',ext:'oscillator'},
      detune: {value:0,param:'detune',label:'Detune',ext:'oscillator'},
      gain: {value:0.5,param:'gain',label:'Gain',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'mixer': {
    title:'Mixer',
    type:'mixer',
    custom:true,
    parameters: {
      input1: {value:'io',param:'input',label:'Input A',ext:'gain1'},
      gain1: {value:0.5,param:'gain',label:'Gain A',ext:'gain1'},
      input2: {value:'io',param:'input',label:'Input B',ext:'gain2'},
      gain2: {value:0.5,param:'gain',label:'Gain B',ext:'gain2'},
      gain: {value:0.5,param:'gain',label:'Mixed Gain',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'stereopanner': {
    title:'Stereo Panner',
    type:'stereopanner',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''},
      pan: {value:0,param:'pan',label:'Pan',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'channelsplitter': {
    title:'Channel Splitter',
    type:'channelsplitter',
    custom:false,
    parameters: {
    input: {value:'io',param:'input',label:'Input',ext:''},
    splitcount: {value:2, param:'splitcount',label:'Split Num',ext:''},
    output0: {value:0, param:'output0',label:'Left',ext:''},
    output1: {value:1, param:'output1',label:'Right',ext:''},
    output2: {value:2, param:'output2',label:'Center',ext:'', display:'none'},
    output3: {value:3, param:'output3',label:'LFE',ext:'', display:'none'},
    output4: {value:4, param:'output4',label:'S Left',ext:'', display:'none'},
    output5: {value:5, param:'output5',label:'S Right',ext:'', display:'none'},
    }
  },
  'channelmerger': {
    title:'Channel Merger',
    type:'channelmerger',
    custom:false,
    parameters: {
    mergecount: {value:'2',param:'mergecount',label:'Merge Num',ext:''},
    input0: {value:'0',param:'input0',label:'Left',ext:''},
    input1: {value:'1',param:'input1',label:'Right',ext:''},
    input2: {value:'2',param:'input2',label:'Center',ext:'', display:'none'},
    input3: {value:'3',param:'input3',label:'LFE',ext:'', display:'none'},
    input4: {value:'4',param:'input4',label:'S Left',ext:'', display:'none'},
    input5: {value:'5',param:'input5',label:'S Right',ext:'', display:'none'},
    output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'constantsource': {
    title:'Constant Source',
    type:'constantsource',
    custom:false,
    parameters: {
    offset: {value:1 ,param:'offset',label:'Offset',ext:''},
    output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'biquadfilter': {
    title:'Biquad Filter',
    type:'biquadfilter',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''},
      type: {value:'lowpass',param:'type',label:'Type',ext:''},
      frequency: {value:1000,param:'frequency',label:'Frequency',ext:''},
      Q: {value:1,param:'Q',label:'Q',ext:''},
      gain: {value:0.5,param:'gain',label:'Gain',ext:''},
      detune: {value:0,param:'detune',label:'Detune',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'convolver': {
    title:'Convolver',
    type:'convolver',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''},
      impulse:{value:'hall',param:'impulse',label:'Impulse',ext:''},
      duration: {value:2, param:'duration',label:'Duration',ext:''},
      decay: {value:2, param:'decay',label:'Decay',ext:''},
      tone: {value:6000, param:'tone',label:'Tone',ext:''},
      preDelay: {value:0.03, param:'preDelay',label:'PreDelay',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'delay': {
    title:'Delay',
    type:'delay',
    custom:false,
    parameters: {
      input: {value:'io',param:'input',label:'Input',ext:''},
      delayTime: {value:0.5,param:'delayTime',label:'DelayTime',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'waveshaper': {
    title:'Wave Shaper',
    type:'waveshaper',
    custom:false,
    parameters: {
      input: {value:'io', param:'input',label:'Input',ext:''},
      mode: {value:'soft', param:'mode',label:'Mode',ext:''},
      curve: {value:[], param:'curve',label:'Curve',ext:'', display:'none'},
      drive: {value:0.5, param:'drive',label:'Drive',ext:''},
      steps: {value:10, param:'steps',label:'Steps',ext:''},
      oversample: {value:'none', param:'oversample',label:'Oversample',ext:''},
      output: {value:'io', param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'bufferSource': {
    title:'Buffer Source',
    type:'buffersource',
    custom:false,
    parameters: {
      playbackRate: {value:1,param:'playbackRate',label:'PlaybackRate',ext:''},
      detune: {value:0,param:'detune',label:'Detune',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'periodicWave': {
    title:'Periodic Wave',
    type:'periodicwave',
    custom:false,
    parameters: {
      real: {value:[1,0,0,0,0,0,0,0,0],param:'real',label:'Real',ext:'', display:'none'},
      imaginary: {value:[0,0,0,0,0,0,0,0,0],param:'imaginary',label:'Imaginary',ext:'', display:'none'},
      disableNormalization: {value:[],param:'disableNormalization',label:'DisableNormalization',ext:'', display:'none'},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'multiVoice': {
    title:'Multi Voice',
    type:'multivoice',
    custom:true,
    parameters: {
      numberOfVoices: {value:3, param:'numberOfVoices',label:'Voices',ext:''},
      curve: {value:2.5, param:'curve', label:'Curve',ext:''},
      oscillator1: {value:'sine', param:'oscillator1',label:'Oscillator 1',ext:''},
      oscillator2: {value:'sawtooth', param:'oscillator2',label:'Oscillator 2',ext:''},
      shape: {value:'power',param:'shape',label:'Shape',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }

  },
  'noise': {
    title:'Noise',
    type:'noise',
    custom:true,
    parameters: {
      playbackRate: {value:1,param:'playbackRate',label:'PlaybackRate',ext:''},
      detune: {value:0,param:'detune',label:'Detune',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'dynamicsCompressor': {
    title:'Dynamics Compressor',
    type:'dynamicscompressor',
    custom:false,
    parameters: {
      input: {value:'io', param:'input',label:'Input',ext:''},
      threshold: {value:-12,param:'threshold',label:'Threshold',ext:''},
      knee: {value:30,param:'knee',label:'Knee',ext:''},
      ratio: {value:12,param:'ratio',label:'Ratio',ext:''},
      attack: {value:0.003,param:'attack',label:'Attack',ext:''},
      release: {value:0.25,param:'release',label:'Release',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'frequencymodulation': {
    title:'Frequency Modulation',
    type:'frequencymodulation',
    custom:true,
    parameters: {
      type: {value:'sine',param:'type',label:'Osc1 Type',ext:'', io:''},
      osc2Freqx: {value:2,param:'osc2Freqx',label:'Osc2 Freq x',ext:'', io:''},
      osc3Freqx: {value:5,param:'osc3Freqx',label:'Osc3 Freq x',ext:'', io:''},
      osc4Freqx: {value:7,param:'osc4Freqx',label:'Osc4 Freq x',ext:'', io:''},
      osc2Gainr: {value:0.4,param:'osc2Freqx',label:'Osc2 Gain r',ext:'', io:''},
      osc3Gainr: {value:0.6,param:'osc3Freqx',label:'Osc3 Gain r',ext:'', io:''},
      osc4Gainr: {value:0.8,param:'osc4Freqx',label:'Osc4 Gain r',ext:'', io:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'modalsynthesis': {
    title:'Modal Synthesis',
    type:'modalsynthesis',
    custom:true,
    parameters: {
      modeName: {value:'drum',param:'modeName',label:'Mode Name',ext:'', io:''},
      modeData: {value:modalSynthesisRatios.drum, param:'modeData',label:'modeData',ext:'', io:'', display:'none'},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
  'panner': {
    title:'Panner',
    type:'panner',
    custom:false,
    parameters: {
      input: {value:'io', param:'input',label:'Input',ext:''},
      positionX: {value:1,param:'positionX',label:'positionX',ext:''},
      positionY: {value:0,param:'positionY',label:'positionY',ext:''},
      positionZ: {value:1,param:'positionZ',label:'positionZ',ext:''},
      orientationX: {value:0,param:'orientationX',label:'orientationX',ext:''},
      orientationY: {value:1,param:'orientationY',label:'orientationY',ext:''},
      orientationZ: {value:0,param:'orientationZ',label:'orientationZ',ext:''},
      distanceModel: {value:'inverse',param:'DistanceModel',label:'distanceModel',ext:''},
      refDistance: {value:1,param:'refDistance',label:'RefDistance',ext:''},
      maxDistance: {value:10000,param:'maxDistance',label:'Max Distance',ext:''},
      rolloffFactor: {value:1,param:'rolloffFactor',label:'RolloffFactor',ext:''},
      coneInnerAngle: {value:360,param:'coneInnerAngle',label:'ConeInnerAngle',ext:''},
      coneOuterAngle: {value:360,param:'coneOuterAngle',label:'CneOuterAngle',ext:''},
      coneOuterGain: {value:0,param:'coneOuterGain',label:'ConeOuterGain',ext:''},
      //setOrientationfunction: {value:null,param:'setOrientationfunction',label:'setOrientationfunction',ext:''},
      //setPositionfunction: {value:null,param:'setPositionfunction',label:'setPositionfunction',ext:''},
      output: {value:'io',param:'output',label:'Output',ext:'', io:'o'},
    }
  },
 }

// --- SVG Functions ---
function createSvg(id, width, height, layer, className){
  const svgElement = document.createElementNS(svgns, 'svg');
  svgElement.setAttributeNS(null, 'id', id);
  svgElement.setAttributeNS(null, 'class', className);
  svgElement.setAttributeNS(null, 'width', width);
  svgElement.setAttributeNS(null, 'height', height);
  if(layer) layer.appendChild(svgElement);
  return svgElement;
}

function createForeignObject(id, pos, width, height, fill, htmlElements, layer, className){
  const foreignObject = document.createElementNS(svgns, 'foreignObject');
  if(id) foreignObject.setAttributeNS(null, 'id', id);
  foreignObject.setAttributeNS(null, 'class', className);
  foreignObject.setAttributeNS(null, 'x', pos.x);
  foreignObject.setAttributeNS(null, 'y', pos.y);
  foreignObject.setAttributeNS(null, 'width', width);
  foreignObject.setAttributeNS(null, 'height', height);
  if(fill) foreignObject.setAttributeNS(null, 'style', 'fill:' + fill + ';');
  foreignObject.appendChild(htmlElements);
  if(layer) layer.appendChild(foreignObject);
  return foreignObject;
}

function createLinearGradient(id, col1){
  const exists = document.getElementById(id);
  if(exists) exists.remove();
  const gradient = document.createElementNS(svgns, 'linearGradient');
  gradient.setAttributeNS(null, 'id', id);
  gradient.setAttributeNS(null, 'gradientTransform', 'rotate(0)');
  const col2 = adjustHex(col1, -10);
  const stopsList = [
    {'col': col1,'pos': '0%'},
    {'col': col1,'pos': '90%'},
    {'col': col2,'pos': '90%'},
    {'col': col2,'pos': '100%'}
  ];
  stopsList.forEach(stopInfo =>{
    const stop = document.createElementNS(svgns, 'stop');
    stop.setAttribute('offset', stopInfo.pos);
    stop.setAttribute('stop-color', stopInfo.col);
    gradient.appendChild(stop);
  });
  dom.svg.tracksDefs.append(gradient);
}

function updateLinearGradients(colors){
  colors.forEach((color,index) => {
    createLinearGradient('track-' + index, color);
    setCssValue('--color-track-' + index, color);
  });
}

function changeTrackColor(color){
  currentTrack.color = color;
  renderTracks();
  saveNodeitData();
}

function adjustHex(hex, percent) {
  let num = parseInt(hex.slice(1), 16);
  let amt = Math.round(2.55 * percent);
  let r = Math.min(255, Math.max(0, (num >> 16) + amt));
  let g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amt));
  let b = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function createCircle(id, pos, r, fill, stroke, strokeWidth, layer, className){
    const circle = document.createElementNS(svgns, 'circle');
    if(id) circle.setAttributeNS(null, 'id', id);
    if(className) circle.setAttributeNS(null, 'class', className);
    circle.setAttributeNS(null, 'cx', pos.x);
    circle.setAttributeNS(null, 'cy', pos.y);
    circle.setAttributeNS(null, 'r', r);
    if(fill) circle.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';');
    layer.appendChild(circle);
    return circle;
}

function createRect(id, pos, width, layer, className){
    width = Math.abs(width);
    const rect = document.createElementNS(svgns, 'rect');
    if(id) rect.setAttributeNS(null, 'id', id);
    if(className!=null) rect.setAttributeNS(null, 'class', className);
    rect.setAttributeNS(null, 'width', width)
    rect.setAttributeNS(null, 'x', pos.x);
    rect.setAttributeNS(null, 'y', pos.y);
    if(layer) layer.appendChild(rect);
    return rect;
}

function createDiv(className, text, id){
  const div = document.createElement('div');
  if(className) div.className = className;
  if(text) div.textContent = text;
  if(id) div.id = id;
  return div
}

function createButton(className, text, id){
  const button = document.createElement('button');
  if(className) button.className = className;
  if(text) button.textContent = text;
  if(id) button.id = id;
  return button;
}

function createPath(pathInfo, fill, stroke, strokeWidth, id, layer, closePath, className){
    if(typeof pathInfo==='string'){
        var d = pathInfo; //is a string
    }else{
        if(pathInfo.length!=0){
            var d = createPathString(pathInfo, closePath); //is a point array
        }else{
            return false;
        }
    }
    const path = document.createElementNS(svgns, 'path');
    path.setAttributeNS(null, 'id', id);
    if(className) path.setAttributeNS(null, 'class', className);
    path.setAttributeNS(null, 'd', d);
    if(fill && stroke){
        path.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + '; stroke-width:' + strokeWidth + ';');
    }
    layer.appendChild(path);
    return path;
}

function createPathString(posList, closePath){
    let d = ` M${posList[0].x} ${posList[0].y}`;
    for(var i=1; i<posList.length; i++) {
        if(posList[i].type ==='control-point'){
          d += ' Q' + posList[i].x + " " + posList[i].y + " " + posList[i+1].x + " " + posList[i+1].y;
        }else{
          d += ` L${posList[i].x} ${posList[i].y}`;
        }
    }
    if(closePath) d += ' z';
    return d;
}

/*
  Approximate an exponential-like curve between two points
  using a quadratic Bezier control point.
  start, end = {x, y}
  curvature = 1 = linear, >1 = exponential (steeper), <1 = ease-out
*/

function exponentialQ(start, end, curvature = 2) {
  const x0 = start.x, y0 = start.y;
  const x2 = end.x,   y2 = end.y;

  // We fit through a midpoint along x
  const t = 0.5;
  const xMid = x0 + (x2 - x0) * t;

  // Compute exponential midpoint (simulated shape)
  // normalize x from 0..1  y(t) = start + (end - start) * ((b^x - 1) / (b - 1))
  const b = curvature;
  const frac = (Math.pow(b, t) - 1) / (b - 1);
  const yMid = y0 + (y2 - y0) * frac;

  // Solve for control point (cx, cy) so quadratic passes through midpoint
  const denom = 2 * (1 - t) * t; // = 0.5 when t = 0.5
  const cx = (xMid - (1 - t)**2 * x0 - t**2 * x2) / denom;
  const cy = (yMid - (1 - t)**2 * y0 - t**2 * y2) / denom;

  //return { cx, cy, d:`M${x0},${y0} Q${cx},${cy} ${x2},${y2}` };
  return `Q${cx} ${cy} ${x2} ${y2}`;
}

// -- Modal ---
function openModal(sectionDiv) {
  document.getElementById('modalBackdrop').style.display = 'flex';
  document.querySelectorAll('.modal-content').forEach(el => {
    el.classList.add('hidden');
  });
  //console.log(sectionDiv);
  document.getElementById(sectionDiv).classList.remove('hidden');
}

function closeModal() {
  document.getElementById('modalBackdrop').style.display = 'none';
}

// --- Toast ---
function addLettersOneByOne(text, delay) {
  let index = 0;
  clearTimeout(letterTimeout);
  function addNextLetter() {
    if (index < text.length) {
      const letter = text.charAt(index);
      dom.el.toast.textContent += letter;
      index++;
      let writeDelay = (letter===' ')? (delay*4):delay;
      //setTimeout(addNextLetter, writeDelay);
      letterTimeout = setTimeout(addNextLetter, writeDelay);
    }
  }
  addNextLetter();
}

function showToast(message, type = 'info', duration = 3000) {
  ////console.log(message)
  //const toast = document.getElementById('toast');
  if (!dom.el.toast) return;
  dom.el.toast.textContent = '';
  addLettersOneByOne(message, 50);
  dom.el.toast.className = `toast show ${type}`;
  // Clear any existing timeout and start a fresh one
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => {dom.el.toast.classList.remove('show');}, duration);
}

function createInput(key, node, parameters){
  let input;
  let options = [];
  const id = generateId();
  const keyIncludesInput = key.includes('input');
  const keyIncludesOutput = key.includes('output');
  const keyList = ['type','mode','oscillator1','oscillator2','shape','impulse','oversample','presets','modeName'];

  if(keyList.includes(key) || (node.type==='waveshaper' && key==='mode')){
    if(node.type==='oscillator' || node.type==='lfo' || node.type==='cosinewave' || key==='oscillator1' || key==='oscillator2' || node.type==='frequencymodulation'){
      options = ['sawtooth','sine', 'square', 'triangle'];
    }else if(node.type==='filter' || node.type==='biquadfilter'){
      options = ['lowpass','highpass','bandpass','lowshelf','highshelf','peaking','notch','allpass'];
    }else if(node.type==='waveshaper' && key==='mode'){
      options = ['soft','hard','fold','sinefold','crush','expo','asym','sigmoid','rectify','pow','tube'];
    }else if(node.type==='waveshaper' && key==='oversample'){
       options = ['none','2x','4x'];
    }else if(node.type==='multivoice' && key==='shape'){
      options = ['power','tanh','sinh','cubic','linear'];
    }else if(node.type==='convolver' && key==='impulse'){
      options = ['hall','room','plate','cathedral','spring'];
    }else if(node.type==='adsr' && key==='presets'){
      options = ['standard','percussive','softPad','punchyBass','organDrone','reverseSwell','bowed','gatedPluck'];
    }else if(key==='modeName'){
      options = ['churchBell','crystalBowl','drum','singingBowl','tibetanCymbal','tunedPipe','woodenBar'];
    }
    input = document.createElement('select');
    options.forEach(opt => {
      option = document.createElement('option');
      option.text = opt;
      option.value = opt;
      option.selected = (opt=== parameters.value)? 'selected':'';
      input.add(option);
      input.onchange = () => inputChange(id, parameters);
    })
  }else if(key==='useNoteFrequency'){
    input = document.createElement('input');
    input.type = 'checkbox';
    console.log(parameters.value)
    input.checked = (parameters.value)? 'checked':'';
    input.onclick = () => inputChange(id, parameters);
  }else if(keyIncludesInput || keyIncludesOutput){
    input = createDiv('hidden','none');
  }else{
    input = document.createElement('input');
    input.type = 'number';
    input.value = parameters.value;
    if(key==='gain') input.step = '0.1';
    input.oninput = () => inputChange(id, parameters);
  }
  input.dataset.id = node.id;
  input.id = id;
  return input;
}

function inputChange(id, parameter){
  const input = document.getElementById(id);
  let inputValue = input.value;
  if(input.type === 'checkbox') inputValue = (input.checked)? true:false;
  console.log (input.type, inputValue)
  ////console.log(id, parameter, currentSound.nodes.find(n => n.id === input.dataset.id))
  if(input){
    const nodeId = input.dataset.id;
    const inputNode = currentSound.nodes.find(n => n.id === nodeId);
    if(inputNode){
      inputNode.parameters[parameter.param].value = inputValue;
      saveNodeitData();
    }
    if(inputNode.type === 'waveshaper') updateWaveshaper(inputNode, nodeId);
    if(inputNode.type === 'convolver') updateConvolver(inputNode, parameter, inputValue);
    if(inputNode.type === 'adsr') updateAdsr(inputNode, parameter, inputValue);
    if(inputNode.type === 'modalsynthesis') updateModalsynthesis(inputNode, parameter, inputValue);
  }
}

function createGraphNodeRow(node, key, parameters){
  const row = createDiv('node-box-row');
  const label = createDiv('node-box-label',  parameters.label);
  const inputContainer = createDiv('node-box-input', null);
  const input = createInput(key, node, parameters);
  const keyIncludesInput = key.includes('input');
  const keyIncludesOutput = key.includes('output');
  inputContainer.appendChild(input);

  if(!keyIncludesOutput && node.type!=='adsr' && parameters.io !== ''){
    const inputConnect = createDiv('input-connect', null);
    inputConnect.dataset.id = node.id;
    inputConnect.dataset.param = parameters.param;
    inputConnect.dataset.ext = parameters.ext;
    inputConnect.onmouseover = () => overHandlerInput(event, inputConnect, node, key);
    inputConnect.onmousedown = () => downHandlerInput(node.id, key, parameters.ext);
    row.appendChild(inputConnect);
  }else{
    row.appendChild(createDiv('input-connect-blank', null));
  }

  row.appendChild(label);
  row.appendChild(inputContainer);

  if(!keyIncludesInput && parameters.io !== ''){
      const outputConnect = createDiv('output-connect', null);
      outputConnect.dataset.id = node.id;
      outputConnect.dataset.param = key;
      outputConnect.onmousedown = () => downHandlerOutput(event, outputConnect, node, key);
      row.appendChild(outputConnect);
  }
  return row;
}

function createGraphNodeBox(pos, node){
  const container = createDiv('node-box-container', null, 'container_' + node.id);

  const titleStr = (node.type==='oscillator' && node.parameters.frequency.value<30)? 'LFO Oscillator':node.title

  const title = createDiv('node-box-title', titleStr); // + ' ' + node.id
  const main = createDiv('node-box-main');
  let numOfParameters = 0;

  if(node.parameters){
    const parameterKeys = Object.keys(node.parameters);
   // numOfParameters = parameterKeys.length;
    parameterKeys.forEach(key => {
      const param = node.parameters[key];
      if(param?.display !== 'none'){
        // Legacy remove
        if(key==='durationMin' || key==='durationMax' || key==='duration'){
          if(node.type === 'adsr'){
            if(node.parameters.duration) delete node.parameters.duration;
            if(node.parameters.durationMin) delete node.parameters.durationMin;
            if(node.parameters.durationMax) delete node.parameters.durationMax;
            console.log(node.parameters);
            saveNodeitData();
          }
        }else{
          row = createGraphNodeRow(node, key, param);
          main.appendChild(row);
          numOfParameters++;
        }
      }
    });
  }

  //insert adsr or waveshaper graph svg
  if(node.type==='adsr' || node.type==='waveshaper' || node.type==='periodicwave'){
    const prefix = node.type;
    const svgGraphContainer = createDiv(`${prefix}-graph`);
    const svgGraph = createSvg(`${prefix}_${node.id}`, 220, 153, null, 'adsr-graph-svg');
    svgGraph.setAttribute('viewBox', '0 0 460 320')
    createPath('M0 0 L0, 0', null, null, null, `${prefix}Line_${node.id}`, svgGraph, false, 'adsr-line dom-svg');
    createRect(null, {x:60, y:40}, 361, svgGraph, 'adsr-grid');
    if(node.type==='adsr') svgGraph.onmousedown = () => setUpAdsr(node);
    if(node.type==='periodicwave') svgGraph.onmousedown = () => setUpPeriodicWave(node, true);
    svgGraphContainer.append(svgGraph)
    main.appendChild(svgGraphContainer);
  }

  container.appendChild(title);
  container.appendChild(main);

  let height = (numOfParameters * 29) + 35;
  if(node.type==='adsr' || node.type==='waveshaper' || node.type==='periodicwave') height += 160;

  const graphBox = createForeignObject('graphBox_' + node.id, pos, 200, height, '#f1f1f1', container, dom.svg.nodeBoxes, 'node-box-html');
  title.onmousedown = () => downHandlerNodeBox(event, node, graphBox, title);
  if(node.type==='waveshaper') updateWaveshaper(node, node.id);
  if(node.type==='periodicwave') setUpPeriodicWave(node, false);

  if(node.type==='adsr'){
    adsr.id = node.id;
    adsrDisplay.points = node.parameters.points.value;
    drawAdsr();
  }
}

function setUpAdsr(node){
  adsrDisplay.points = node.parameters.points.value;
  adsr.id = node.id;
  // Set text
  dom.svg.adsrTime.textContent = `Duration Min: ${currentSound.minDuration} - Max: ${currentSound.maxDuration}`;
  dom.svg.adsrAmpMax.textContent = node.parameters.ampMax.value;
  dom.svg.adsrAmpMin.textContent = node.parameters.ampMin.value;

  drawAdsr();
  openModal('modalAdsr');
}

function updateLines(){
  const tempLine = document.getElementById('tempLine');
  if(tempLine) tempLine.remove();

  currentSound.nodes.forEach(node =>{
  node.connections.forEach((connection, index) =>{
    //Has to go from an output to an input  id + param + io
    const startPos = connectPoints.find(p => p.id === node.id && p.parameter === connection.startParam  && p.io === 'output')?.position;
    const endPos = connectPoints.find(p => p.id === connection.id && p.parameter === connection.destParam  && p.io === 'input')?.position;
    //if node has been removed but connection remains clean up
    if(!startPos || !endPos){
      ////console.log(node, connection, connectPoints)
      node.connections.splice(index, 1);
      saveNodeitData();
    }else{
      const xDifference = (endPos.x - startPos.x)/2;
      const center = {x:startPos.x + xDifference, y:startPos.y + ((endPos.y - startPos.y)/2)};
      const curveAmount = xDifference/2;
      const path = `M${startPos.x} ${startPos.y} Q${startPos.x + curveAmount} ${startPos.y} ${center.x} ${center.y}  Q${endPos.x - curveAmount} ${endPos.y} ${endPos.x} ${endPos.y}`;
      drawConnectingLine(path, 'cl_' + node.id + '_' + index);
    }
  });
  });
}

function updateConnectPoints(){
  connectPoints = [];
  function updateconnect(className, io){
    document.querySelectorAll(className).forEach(el => {
      const position = getTransformedElementPosition(el, dom.svg.graphSvg);
      const id = (el.dataset?.ext)? `${el.dataset.id}_${el.dataset.ext}`:el.dataset.id;
      connectPoints.push(new Connector(id, position, el.dataset.param, io, el.dataset?.ext));
    });
  }
  updateconnect('.input-connect', 'input');
  updateconnect('.output-connect', 'output');
  updateLines();
 }

function connectNode(fromNode, toNode, startParam, destParam){
  fromNode.connections.push({id:toNode.id, startParam:startParam, destParam:destParam});
}

function addToGraphNodes(nodeGroup, ctxNode, id){
  nodeGroup[id] = ctxNode;
}

function clearMasterBusNodes(){
  Object.keys(masterBusNodes).forEach(key =>{
      masterBusNodes[key].disconnect();
      delete graphNodes[key]; //disconnected now delete
  });
}

function stopSound(buildId){
  Object.keys(graphNodes).forEach(key =>{
    if(key.includes(buildId) || buildId==='all' ){
      if(key==='mastergain'){
        //console.log('mastergain')
      }
      graphNodes[key].disconnect();
      delete graphNodes[key]; //disconnected now delete
    }
  });
}

function changeModeOrDuration(duration = 4){ //duration only affects online
  //nodeData.mode = dom.ctrl.modeSelect.value;

  if(!nodeData.ctx) nodeData.ctx = new AudioContext();

  if(nodeData.mode === 'offline' || nodeData.mode === 'render'){
    nodeData.offlineDuration = duration;
    nodeData.ctx = createOffline(duration);
  }else if (nodeData.mode === 'context'){
    //const sampleRate = Number(dom.sampleRateSelect.value);
    const sampleRate = nodeData.ctx.sampleRate
    nodeData.ctx = new AudioContext({ sampleRate: sampleRate});
  }else{
    console.error(nodeData.mode, 'not available')
  }
  nodeData.now = nodeData.ctx.currentTime;
  setupMasterCompressorandGain();
  saveNodeitData();
}

function beatFromTempo(tempo){
  return (60 / tempo); // in seconds add * 1000; for duration in ms
}

function cloneObject(obj, changeId){
  const clone = JSON.parse(JSON.stringify(obj));
  if(changeId) clone.id = generateId();
  return clone;
}

function convertBeatsToSeconds(start, note){
  const noteClone = cloneObject(note)
  noteClone.duration = (noteClone.envelopeLength * beatDuration); //envelopeLength
  noteClone.time = start + (noteClone.beat * beatDuration);   //converted.duration;
  return noteClone;
}

function ensureAudioContext(){

  const isOffline = nodeData.ctx instanceof OfflineAudioContext;
  if(isOffline) return;

  if(nodeData.ctx?.state){ //state can be read
    if(nodeData.ctx.state!=='running'){ //state is not running so create
      changeModeOrDuration();
    }
  }else{ //state cannot be read so create
    changeModeOrDuration();
  }
}

function playSound(note, trackGainInfo){
  console.log(note)
  const buildId = generateId();
  let osc, buffer;

  ensureAudioContext();
  if(!note) note = {title:'d4', time:nodeData.ctx.currentTime, duration:2};
  const frequency = noteList[note.title];
  const time = note.time;
  buildGraph(buildId, frequency, note, trackGainInfo);

  //let minDuration = 0;
  //let maxDuration = 0;
  let noteDuration = Number(note.duration);

  const defaultNote = (currentSound.defaultNote)? currentSound.defaultNote:'a4';
  const minDuration = (currentSound.minDuration)? Number(currentSound.minDuration):0;
  const maxDuration = (currentSound.maxDuration)? Number(currentSound.maxDuration):0;

  // Make note at least as long as min duration
  if(note.duration < minDuration) noteDuration = minDuration;
  // Clamp note to max
  if(noteDuration > maxDuration && maxDuration!==0) noteDuration = maxDuration;

  currentSound.nodes.forEach(node => {
    if(node.type==='adsr'){
      node.connections.forEach(connection =>{
      const adsrConnect = graphNodes[`${buildId}_${connection.id}`];
      if(connection.destParam === 'gain'){
        adsrConnect.gain.setValueAtTime(0, nodeData.now); //set to zero so envelope works properly
      }
      const ampMax = Number(node.parameters.ampMax.value);
      const ampMin = Number(node.parameters.ampMin.value);

      node.parameters.points.value.forEach((point, index) => {

        let adsrValue = Number(point.amp) * (ampMax + ampMin);
        if(adsrValue===0) adsrValue = 0.001; //exponential curve requires non 0
        const adsrTime =  time + (noteDuration * Number(point.time)); //resizes adsr points over time

        if(point.line==='set'){
          adsrConnect[connection.destParam].setValueAtTime(adsrValue, adsrTime); //set
        }else if(point.line==='curve'){
          adsrConnect[connection.destParam].exponentialRampToValueAtTime(adsrValue, adsrTime); //exponential curve
        }else{
          adsrConnect[connection.destParam].linearRampToValueAtTime(adsrValue, adsrTime); //linear
        }
      });
    });
    }else if(node.type==='oscillator' || node.type==='periodicwave'){
      osc = graphNodes[`${buildId}_${node.id}`];
      osc.start(time);
      //Any oscilator not including lfo
      if(!node.lfo){ // more than 3o hZ
        osc.frequency.setValueAtTime(frequency, time);
      }
    }else if(node.type==='gain'){
      //const gain = graphNodes[`${buildId}_${node.id}`];
      //gain.gain.setValueAtTime(0.001, nodeData.ctx.currentTime);
    }else if(node.type==='noise'){
      buffer = graphNodes[`${buildId}_${node.id}`];
    }else if(node.type==='waveshaper'){
      //buffer = graphNodes[`${buildId}_${node.id}`];

    }else if(node.type==='constantsource'){
      const constantsource = graphNodes[`${buildId}_${node.id}`];
      constantsource.start(time);
    }
  });

  //stop noise buffer
  if(buffer){
    buffer.start(time);
    buffer.stop(time + noteDuration + 0.05);
    ////console.log('stopping buffer')
  }

  // Silent osc to close out .onended
  if(!osc){
    osc = nodeData.ctx.createOscillator();
    osc.start();
  }
  //console.log(time, noteDuration)
  // Stop and clean up
  osc.stop(time + noteDuration + 0.05);
    osc.onended = () => {
    stopSound(buildId);
  }
  return buildId;
}

function setAnimationOn(bool){
  nodeData.animationOn = bool;
  dom.ctrl.animationCheck.checked = bool;
  saveNodeitData();
}

// --- Visual for Tracks when Playing ---
function highlightNotes(notes, startBuffer, songDuration) {
  // create a local state for whats active
  notes.sort((a,b) => a.time - b.time);
  let count = 0;
  let interval;
  dom.svg.timeBar.setAttribute('class', 'time-bar');
  const startTime = nodeData.ctx.currentTime;

  notes.forEach(note => {note.playing = false });
  function update() {
    const now = nodeData.ctx.currentTime;
    notes.forEach(note => {
      const el = dom.notes[note.id]; //set when createNoteBox is called
      if (!el) return;
      const noteStart = note.time;
      const noteEnd = note.time + note.duration;

      // Should it be on?
      const on = now >= note.time && now <= (note.time + note.duration);
      if (on && !note.playing) {
          note.playing = true;
          el.classList.add('note-playing');
      } else if (!on && note.playing) {
          note.playing = false;
          el.classList.remove('note-playing');
      }
    });

    // Update bar position
    const time =  nodeData.ctx.currentTime - startTime - startBuffer;
    // Convert seconds to beats
    const beatTime = time/beatDuration;
    const xpos = (svgData.beatScale * beatTime) + svgData.beatScale;
    dom.svg.timeBar.setAttribute('x', xpos);

    if(time < songDuration){
      requestAnimationFrame(update);
    }else{
      dom.svg.timeBar.setAttribute('class', 'time-bar-hidden');
      //console.log('count', count);
      clearGraphNodesMix();
    }
  }
  if(count===0){
    count = 1;
    update(); // start loop once
  }
}

// --- Waveshaper Functions ---
function updateWaveshaper(node, id){
  ////console.log(node, id)
  const curve = makeCurve(node.parameters.mode.value, node.parameters.drive.value, node.parameters.steps.value, node.parameters.oversample.value);
  ////console.log(id, curve, 'waveshaperLine_' + id)
  const line = document.getElementById('waveshaperLine_' + id)
  drawCurve(curve, document.getElementById('waveshaperLine_' + id), 360, 240);
  node.parameters.curve.value = curve
}

function makeCurve(mode, drive = 1, steps = 8) {
  const n = 1024;
  const curve = new Float32Array(n);

  for (let i = 0; i < n; i++) {
    const x = (i / (n - 1)) * 2 - 1;
    let y = x;

    switch (mode) {
      case 'soft': // soft clip
        y = Math.tanh(x * drive);
        break;
      case 'hard': // hard clip
        const a = 1 / drive;
        y = Math.max(-a, Math.min(a, x)) * (1 / a);
        break;
      case 'fold': // foldback distortion
        y = Math.abs(((x * drive + 1) % 2) - 1) * 2 - 1;
        break;
      case 'sinefold': // sine folding
        y = Math.sin(x * drive * Math.PI);
        break;
      case 'crush': // bit crush
        y = Math.round(x * steps) / steps;
        break;
      case 'expo': // exponential shaping
        y = Math.sign(x) * (1 - Math.exp(-Math.abs(x * drive)));
        break;
      case 'asym': // asymmetrical distortion
        y = x < 0 ? Math.tanh(x * drive * 0.5) : Math.tanh(x * drive);
        break;
      case 'sigmoid': // logistic saturation
        y = (2 / (1 + Math.exp(-x * drive * 4))) - 1;
        break;
      case 'rectify': // half-wave rectifier
        y = Math.max(0, x * drive);
        break;
      case 'pow': // power curve
        const p = Math.max(0.1, drive); // prevent zero/negative exponent
        y = Math.sign(x) * Math.pow(Math.abs(x), 1 / p);
        break;
      case 'tube': // polynomial tube saturation
        const d = Math.min(drive, 10);
        y = (3 + d) * x * 20 * Math.PI / 180 / (Math.PI + d * Math.abs(x));
        break;
    }
    // keep it in [-1, 1] to avoid digital clipping explosions
    curve[i] = Math.max(-1, Math.min(1, y));
  }
  return curve;
}

// Draw WaveShaper curve
function drawCurve(curveArray, line, width, height, pad) {
  const midY = height / 2;
  let d = '';
  for (let i = 0; i < curveArray.length; i++) {
    let x = (i / (curveArray.length - 1)) * width;
    let y = midY - curveArray[i] * midY;
    //x = midY - curveArray[i] * midY;
    x += adsrDisplay.pad.x;
    y += adsrDisplay.pad.y;
    d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
  }
  line.setAttribute('d', d);
}

function updateWaveshaperComponent(){
  waveshaper.drive = Math.floor(Number(ctrl.waveshaperDriveRange.value)/10);
  waveshaper.steps = Math.floor(Number(ctrl.waveshaperStepRange.value)/10);
  waveshaper.mode = ctrl.waveshaperModeSelect.value;
  const curve = makeCurve();
  drawCurve(curve);
}

function jsonToFloat32(obj){
  const length = Object.keys(obj).length;
  const arr = new Float32Array(length);

  for (let i = 0; i < length; i++) {
    arr[i] = obj[i];
  }
  return arr;
}

// For FM Chain
function setModIndexFromBeta(opGainNode, modOsc, targetBeta) {
  const fm = modOsc.frequency.value;           // e.g. 440
  const deltaF = targetBeta * fm;              // f =  * fm
  opGainNode.gain.setValueAtTime(deltaF, modOsc.context.currentTime);
  console.log(deltaF)
  return deltaF; // informative
}

function buildGraph(buildId, frequency, note, trackGainInfo){
  sound = currentSound;
  let nodeGroup = graphNodes;
  if(sound?.isMasterBus){
    clearMasterBusNodes(); //clear;
    nodeGroup = masterBusNodes;
  }
  const time = nodeData.ctx.currentTime;
  let audionode;
  currentSound.nodes.forEach(node =>{
    let id = (buildId)? `${buildId}_${node.id}`:node.id;
    audionode = null;
    if(node.type === 'oscillator'){
      audionode = nodeData.ctx.createOscillator();
      const frequency = node.parameters.frequency.value;
      node.lfo = (frequency<30)? true:false; //is it an lfo?
      audionode.type = node.parameters.type.value;
      //audionode.detune.setValueAtTime(node.parameters.detune.value, time);
      audionode.frequency.setValueAtTime(frequency, time);
    }else if(node.type === 'gain'){
      audionode = nodeData.ctx.createGain();
      audionode.gain.setValueAtTime(node.parameters.gain.value, time);
    }else if(node.type === 'filter' || node.type ==='biquadfilter'){
      audionode = nodeData.ctx.createBiquadFilter();
      audionode.type = node.parameters.type.value;
      audionode.frequency.setValueAtTime(node.parameters.frequency.value, time);
      audionode.Q.setValueAtTime(node.parameters.Q.value, time);
      audionode.detune.setValueAtTime(node.parameters.detune.value, time);
      audionode.gain.setValueAtTime(node.parameters.gain.value, time);
    }else if(node.type === 'stereopanner'){
      audionode = nodeData.ctx.createStereoPanner();
      audionode.pan.setValueAtTime(node.parameters.pan.value, time);
    }else if(node.type === 'delay'){
      audionode = nodeData.ctx.createDelay();
      audionode.delayTime.setValueAtTime(node.parameters.delayTime.value, time);
    }else if(node.type === 'channelsplitter'){
      //audionode = nodeData.ctx.createChannelSplitter(node.parameters.splitcount.value);
      audionode = nodeData.ctx.createChannelSplitter(2);
    }else if(node.type === 'channelmerger'){
      //console.log('channelmerger', node.parameters.mergecount.value)
      //audionode = nodeData.ctx.createChannelMerger(node.parameters.mergecount.value);
      audionode = nodeData.ctx.createChannelMerger(2);
    }else if(node.type === 'constantsource'){
      //Controlled by gain
      audionode = nodeData.ctx.createConstantSource();
      audionode.offset.setValueAtTime(node.parameters.offset.value, time);
    }else if(node.type === 'waveshaper'){
      audionode = nodeData.ctx.createWaveShaper();
      let curve = node.parameters.curve.value;
      let oversample =  node.parameters.oversample.value;
      if(!(curve instanceof Float32Array)){
        curve = jsonToFloat32(curve);
        node.parameters.curve.value = curve;
      }
      audionode.curve = curve;
      if(oversample==='2x' || oversample==='4x'){
        audionode.oversample = oversample;
      }
    }else if(node.type === 'bufferSource'){
      audionode = nodeData.ctx.createBufferSource();
      audionode.playbackRate.setValueAtTime(node.parameters.playbackRate.value, time);
      audionode.detune.setValueAtTime(node.parameters.detune.value, time);
      //oscStartList.push(id);
    }else if(node.type === 'periodicwave'){
      const real = new Float32Array(node.parameters.real.value);
      const imaginary = new Float32Array(node.parameters.imaginary.value);
      const wave = nodeData.ctx.createPeriodicWave(real, imaginary);
      audionode = nodeData.ctx.createOscillator();
      audionode.setPeriodicWave(wave);
    }else if(node.type === 'convolver'){
      audionode = nodeData.ctx.createConvolver();
      const impulse = node.parameters.impulse.value;
      const duration = node.parameters.duration.value;
      const decay = node.parameters.decay.value;
      const tone = node.parameters.tone.value;
      const preDelay = node.parameters.preDelay.value;
      // Only create if there is no impulse or params have changed
      if (!reverb.buffer instanceof AudioBuffer || reverb.impulse!=impulse || reverb.duration!=duration || reverb.decay!=decay || reverb.tone!=tone || reverb.preDelay!=preDelay) {
        reverb.buffer = createInternalImpulse(duration, decay, tone, preDelay);
        Object.assign(reverb, {impulse,duration,decay,tone,preDelay});
      }
      audionode.buffer = reverb.buffer;
    }else if(node.type === 'panner'){
      audionode = nodeData.ctx.createPanner();
      audionode.positionX.setValueAtTime(node.parameters.positionX.value, time);
      audionode.positionY.setValueAtTime(node.parameters.positionY.value, time);
      audionode.positionZ.setValueAtTime(node.parameters.positionZ.value, time);
      audionode.orientationX.setValueAtTime(node.parameters.orientationX.value, time);
      audionode.orientationY.setValueAtTime(node.parameters.orientationY.value, time);
      audionode.orientationZ.setValueAtTime(node.parameters.orientationZ.value, time);
    }else if(node.type === 'allnodes'){ //treat as gain
      audionode = nodeData.ctx.createGain();
      audionode.gain.setValueAtTime(1, time);
      // Set as connection node ! important
      if(sound.isMasterBus) masterConnect = audionode;
    }else if(node.type === 'dynamicscompressor'){
      audionode = nodeData.ctx.createDynamicsCompressor();
      audionode.threshold.setValueAtTime(node.parameters.threshold.value, time);
      audionode.knee.setValueAtTime(node.parameters.knee.value, time);
      audionode.ratio.setValueAtTime(node.parameters.ratio.value, time);
      audionode.attack.setValueAtTime(node.parameters.attack.value, time);
      audionode.release.setValueAtTime(node.parameters.release.value, time);
    }else if(node.type === 'noise'){
      audionode = nodeData.ctx.createBufferSource();
      audionode.buffer = whiteNoise();
      audionode.playbackRate.setValueAtTime(node.parameters.playbackRate.value, time);
      audionode.detune.setValueAtTime(node.parameters.detune.value, time);
      audionode.loop = true;
    }else if(node.type === 'lfo'){
      const lfoOsc = nodeData.ctx.createOscillator();
      lfoOsc.type = node.parameters.type.value;
      lfoOsc.frequency.setValueAtTime(node.parameters.frequency.value, time);
      addToGraphNodes(nodeGroup, lfoOsc, id + '_oscillator'); //extension declared in definition
      audionode = nodeData.ctx.createGain();
      audionode.gain.setValueAtTime(node.parameters.gain.value, time);
      lfoOsc.connect(audionode);
      lfoOsc.start();
    }else if(node.type === 'frequencymodulation'){
      //const frequency = Number(node.parameters.frequency.value);
      const osc2Freqx = Number(node.parameters.osc2Freqx.value);
      const osc3Freqx = Number(node.parameters.osc3Freqx.value);
      const osc4Freqx = Number(node.parameters.osc4Freqx.value);
      const osc2Gainr = Number(node.parameters.osc2Gainr.value);
      const osc3Gainr =  Number(node.parameters.osc3Gainr.value);
      const osc4Gainr = Number(node.parameters.osc4Gainr.value);

      const op1 = nodeData.ctx.createOscillator();
      op1.frequency.setValueAtTime(frequency, time);
      op1.type = node.parameters.type.value;

      const op2 = nodeData.ctx.createOscillator();
      op2.frequency.setValueAtTime(frequency * osc2Freqx, time);

      const op3 = nodeData.ctx.createOscillator();
      op3.frequency.setValueAtTime(frequency * osc3Freqx, time);

      const op4 = nodeData.ctx.createOscillator();
      op4.frequency.setValueAtTime(frequency * osc4Freqx, time);

      const op1Gain = nodeData.ctx.createGain();
      const op2Gain = nodeData.ctx.createGain();
      const op3Gain = nodeData.ctx.createGain();
      const op4Gain = nodeData.ctx.createGain();

      setModIndexFromBeta(op4Gain, op4, osc4Gainr);
      setModIndexFromBeta(op3Gain, op3, osc3Gainr);
      setModIndexFromBeta(op2Gain, op2, osc2Gainr);

      op1.connect(op1Gain);
      op2.connect(op2Gain);
      op3.connect(op3Gain);
      op4.connect(op4Gain);

      op1Gain.gain.value = 0.3;
      op2Gain.connect(op1.frequency);
      op3Gain.connect(op2.frequency);
      op4Gain.connect(op3.frequency);

      op1.start(note.time);
      op2.start(note.time);
      op3.start(note.time);
      op4.start(note.time);

      op1.stop(note.time + note.duration);
      op2.stop(note.time + note.duration);
      op3.stop(note.time + note.duration);
      op4.stop(note.time + note.duration);

      // Feedback on 3
      const fb = nodeData.ctx.createGain();
      fb.gain.value = 0.2;
      op3.connect(fb);
      fb.connect(op3.frequency);
      audionode = op1Gain;
    }else if(node.type === 'modalsynthesis'){
      audionode = nodeData.ctx.createGain();
      audionode.gain.value = 1;
      const modes = node.parameters.modeData.value;
      let maxDecay = 0;
      for (const m of modes) {
        if(m.decay > maxDecay) maxDecay = m.decay;
      };
      const output = nodeData.ctx.createGain();
      output.gain.value = 1/modes.length;
      output.connect(audionode);
      for (const m of modes) {
        const osc = nodeData.ctx.createOscillator();
        const gain = nodeData.ctx.createGain();
        osc.frequency.value = frequency * m.ratio;
        // Strike envelope
        gain.gain.setValueAtTime(0.0001, note.time);
        gain.gain.exponentialRampToValueAtTime(1.0, note.time + 0.005); // attack
        const newDecay = (m.decay/maxDecay) * note.duration;
        gain.gain.exponentialRampToValueAtTime(0.0001, note.time + newDecay); // decay
        //gain.gain.exponentialRampToValueAtTime(0.0001, note.time + m.decay); // decay
        osc.connect(gain);
        gain.connect(output);
        osc.start(note.time);
        osc.stop(note.time + m.decay + 0.1);
      }
    }else if(node.type === 'cosinewave'){
      // Creates a perfect cosine
      const real = new Float32Array([0, 1]);  // cosine term
      const imag = new Float32Array([0, 0]);  // no sine term
      const cosWave = nodeData.ctx.createPeriodicWave(real, imag);
      const frequency = (node.parameters.useNoteFrequency.value)? noteList[note.title]:node.parameters.frequency.value;
      audionode = nodeData.ctx.createOscillator();
      audionode.setPeriodicWave(cosWave);
      audionode.type = node.parameters.type.value;
      audionode.frequency.value = frequency;
      audionode.start(note.time);
      audionode.stop(note.time + note.duration);
      //detune?
    }else if(node.type === 'mixer'){
      audionode = nodeData.ctx.createGain();
      audionode.gain.setValueAtTime(node.parameters.gain.value, time);
      const gain1 = nodeData.ctx.createGain();
      gain1.gain.setValueAtTime(node.parameters.gain1.value, time);
      const gain2 = nodeData.ctx.createGain();
      gain2.gain.setValueAtTime(node.parameters.gain2.value, time);
      addToGraphNodes(nodeGroup, gain1, id + '_gain1');
      addToGraphNodes(nodeGroup, gain2, id + '_gain2');
      gain1.connect(audionode);
      gain2.connect(audionode);
    }else if(node.type === 'multivoice'){
      audionode = nodeData.ctx.createGain();
      audionode.gain.setValueAtTime(0.7, time);
      //get multivoice list
      const voiceList = unison(
        frequency,
        node.parameters.numberOfVoices.value,
        node.parameters.shape.value,
        node.parameters.curve.value,
        node.parameters.oscillator1.value,
        node.parameters.oscillator2.value);
       voiceList.forEach(voice => {
         const osc = new OscillatorNode(nodeData.ctx, { type: voice.oscillatorType, frequency: voice.frequency });
         osc.start(note.time + voice.phaseOffset);
         osc.stop(note.time + note.duration + voice.phaseOffset);
         //create panner
         const pan = nodeData.ctx.createStereoPanner();
         pan.pan.setValueAtTime(voice.panValue, time);
         //create gain
         const gain = new GainNode(nodeData.ctx, {gain: voice.gainValue});
         osc.connect(pan).connect(gain)
         gain.connect(audionode);
         osc.onended = () => {
           pan.disconnect();
           gain.disconnect()
         }
      });
    }else if(node.type === 'adsr'){
      //
    }else if(node.type === 'destination'){
      audionode = nodeData.ctx.destination;
    }

    if(audionode){
        addToGraphNodes(nodeGroup, audionode, id);

    }
  });

    // Now graph nodes have been created we can connect
  currentSound.nodes.forEach(node =>{
    const id = (buildId)? `${buildId}_${node.id}`:node.id;
    let channelNumber = 0;
    const connectFromNode = nodeGroup[id];
    node.connections.forEach(connection =>{
      const includesInput = connection.destParam.includes('input');
      const connectToId = (buildId)? `${buildId}_${connection.id}`:connection.id;
      let connectToNode = nodeGroup[connectToId];
      //console.log('connecting', nodeGroup[id], 'to', nodeGroup[connectToId], 'param', connection.destParam)
      //console.log('connecting', id, 'to', connection.id, 'param', connection.destParam, node)
      if(connectToNode instanceof AudioDestinationNode){
        if(sound.isMasterBus){
          connectFromNode.connect(connectToNode); //standard connect to destination
          return;
        }
        // Is a destination node so connect to master gain rather than destination
        if(trackGainInfo){
          if(!graphNodesMix[trackGainInfo.id]){
            const trackGain  = nodeData.ctx.createGain();
            trackGain.gain.setValueAtTime(trackGainInfo.gain, time);
            graphNodesMix[trackGainInfo.id] = trackGain;
            connectFromNode.connect(trackGain);
            trackGain.connect(masterConnect);
          }else{
            const trackGain = graphNodesMix[trackGainInfo.id];
            connectFromNode.connect(trackGain);
            trackGain.connect(masterConnect);
          }
        }else{
          connectFromNode.connect(masterConnect);
        }
      }else if(connectToNode instanceof ChannelMergerNode){
        const channelNumber = Number(connection.destParam.replace('input', ''));
        //if not from splitter output will only be zero
        connectFromNode.connect(connectToNode, 0, channelNumber);
        //}
      } else if(node.type==='channelsplitter'){
        const channelNumber = Number(connection.startParam.replace('output', ''));
        connectFromNode.connect(connectToNode, channelNumber);
      } else if(node.type==='adsr'){
        //
      }else{
        const connectTo = (buildId)? `${buildId}_${connection.id}`:connection.id;
        if(includesInput){
         const connectFrom = id;
          nodeGroup[connectFrom].connect(nodeGroup[connectTo]);
          //console.log(connectFrom, nodeGroup[connectFrom], connectTo, nodeGroup[connectTo], currentSound)
        }else{
          // Connect to param
          nodeGroup[id].connect(nodeGroup[connectTo][connection.destParam]);
          //console.log('other', connection.destParam)
        }
      }
    });
  });
}

function updateSoundInfo(prop, ctrl){
  currentSound[prop] = ctrl.value;
  saveNodeitData();
}

function soundInfoRows(label, type, prop, val){
  const row = createDiv('sound-info-row');
  const rowLabel = createDiv('sound-info-label', label);
  const rowInput = createDiv('sound-info-input');
  if(type==='number'){
    const input = document.createElement('input');
    input.type = 'number'
    input.value = val;
    input.oninput = () => updateSoundInfo(prop,  input);
    rowInput.appendChild(input);
  }
  if(type==='note'){
    const select = document.createElement('select');

    noteListKeys.forEach(key =>{
      const option = document.createElement('option');
      option.text = key;
      option.value = key;
      option.selected = (key === val)? 'selected':'';
      select.appendChild(option);
    });
    select.onchange =  () => updateSoundInfo(prop, select);
    rowInput.appendChild(select);
  }
  row.appendChild(rowLabel);
  row.appendChild(rowInput);
  return row
}

function renderSound(){
  if(!renderSoundReady) return;
  dom.svg.soundInfo.innerHTML = '';
  dom.svg.nodeBoxes.innerHTML = '';
  //draw boxes
  currentSound.nodes.forEach(node =>{
    createGraphNodeBox(node.position, node);
  });
  //draw lines
  updateConnectPoints();

  // Draw sound info
  const container = createDiv('sound-info-container');
  const titleRow = soundInfoRows(currentSound.title);
  const location = (currentSound.location === 'song')? currentSong.title:'Sound';
  const locationRow = soundInfoRows(location);
  const defaultNote = (currentSound.defaultNote)? currentSound.defaultNote:'a4';
  const minDuration = (currentSound.minDuration)? currentSound.minDuration:0;
  const maxDuration = (currentSound.maxDuration)? currentSound.maxDuration:0;
  const noteRow = soundInfoRows('Default Note','note', 'defaultNote', defaultNote);
  const minRow = soundInfoRows('Min Duration', 'number', 'minDuration', minDuration);
  const maxRow = soundInfoRows('Max Duration', 'number', 'maxDuration', maxDuration);

  container.appendChild(titleRow);
  container.appendChild(locationRow);
  container.appendChild(noteRow);
  container.appendChild(minRow);
  container.appendChild(maxRow);
  createForeignObject('soundBox', {x:10, y:10}, 220, 200, null, container, dom.svg.soundInfo, 'sound-info');

  // Set zoom
  if(!currentSound.zoom) currentSound.zoom = 1; // Legacy remove
  dom.ctrl.soundZoomRange.value = currentSound.zoom * 100;
  changeSoundZoom();
}

function getTransformedElementPosition(element, svgElement){
  const rect = element.getBoundingClientRect();
  // Create an SVGPoint for the center
  const pt = svgElement.createSVGPoint();
  pt.x = rect.left + rect.width / 2;
  pt.y = rect.top + rect.height / 2;
  // Convert from screen (viewport) to SVG coordinates
  const svgPoint = pt.matrixTransform(svgElement.getScreenCTM().inverse());
  return svgPoint;
}

function getMouseTransformed(evt, svgElement){
  const mouse = {x: evt.clientX, y: evt.clientY}
  const pt = svgElement.createSVGPoint();  // Created once for document
  pt.x = mouse.x;
  pt.y = mouse.y;
  var cursorpt =  pt.matrixTransform(svgElement.getScreenCTM().inverse());
  return cursorpt;
}

function binarySearch(path, lineLength, point) {
    let mid = null;
    // Binary search along path length to find point with position.x
    let lo = 0, hi = lineLength, pt;
    for (let j = 0; j < 20; j++) { // 20 iterations = plenty accurate
      mid = (lo + hi) / 2;
      pt = path.getPointAtLength(mid);
      if (pt.x < point.x) lo = mid; else hi = mid;
    }
  return {x:niceNum(pt.x), y:niceNum(pt.y), lineLength:niceNum(mid), type:point.type};
}

function drawAdsr(){
  let path = '';

  // Remove control points exeed the number of points
  const pointLength = adsrDisplay.points.length;
  dom.svg.pointLayer.querySelectorAll('.svg-point').forEach(circle =>{
    if(pointLength-1 < Number(circle.dataset.id)){
      circle.remove();
    }
  });
  adsrDisplay.points.forEach((point, index) => {
    const pos = timeAmpToNorm(point);
    //const nextPoint = adsrDisplay.points[index-1]
    const id = 'adsrPoint' + index;
    const el = document.getElementById(id)
    if(el){
      el.setAttribute('cx', pos.x);
      el.setAttribute('cy', pos.y);
    }else{
      const circle = createCircle(id, pos, 4, null, null, null, dom.svg.pointLayer, 'svg-point');
      circle.dataset.id = index;
      circle.onmousedown = () => downHandlerAdsrCircle(event, adsrDisplay.points, index, '');
    }
    if(index===0){
      path += `M${pos.x} ${pos.y}`;
    }else if(point.line === 'curve'){
      path += `L${pos.x} ${pos.y} `
      path += exponentialQ(timeAmpToNorm(adsrDisplay.points[index]), timeAmpToNorm(adsrDisplay.points[index+1]), 5);
    }else{
      path += `L${pos.x} ${pos.y} `
    }
  });
  dom.svg.adsrLine.setAttribute('d', path);

  if(adsr.id){
    const line = document.getElementById('adsrLine_' + adsr.id);
    if(line){
      line.setAttribute('d', path);
    }
  }
  //const quad = exponentialQ(timeAmpToNorm(adsrDisplay.points[0]), timeAmpToNorm(adsrDisplay.points[1]), 5)
  //createPath(quad.d, null, null, null, 'quad', dom.svg.lineLayer, false, 'connect-line');
}

function downHandlerAdsrCircle(event, points, index, id){
  if(adsr.mode === 'remove'){
    adsrRemovePoint(index);
  }else{
    adsr.drag = true
    adsr.index = index;
    adsr.pointList = points;
    const point = adsr.pointList[adsr.index];
    dom.ctrl.adsrAmplitudeText.value = point.amp;
    dom.ctrl.adsrTimeText.value = point.time;
    dom.ctrl.adsrPointSelect.value = point.point;
    dom.ctrl.adsrLineSelect.value = point.line;
  }
}

function moveHandlerAsdr(evt){
  if(adsr.drag){
    const mousePosition = getMouseTransformed(evt, dom.svg.adsrSvg);
    if(mousePosition.x<adsrDisplay.pad.x) mousePosition.x = adsrDisplay.pad.x
    if(mousePosition.y<adsrDisplay.pad.y) mousePosition.y = adsrDisplay.pad.y
    if(mousePosition.x>adsrDisplay.pad.x + adsrDisplay.dimensions.x) mousePosition.x = adsrDisplay.pad.x + adsrDisplay.dimensions.x;
    if(mousePosition.y>adsrDisplay.pad.y + adsrDisplay.dimensions.y) mousePosition.y = adsrDisplay.pad.y + adsrDisplay.dimensions.y;
    // Check that number is non 0 for exp
    const timeAmp = normToAmpTime(mousePosition);
    adsr.pointList[adsr.index].time = timeAmp.time;
    adsr.pointList[adsr.index].amp = timeAmp.amp;
    drawAdsr();
  }else if (adsr.mode === 'add'){
    // If in add node mode
    const mousePosition = getMouseTransformed(evt, dom.svg.adsrSvg);
    const mp = mousePosition;
    const ad = adsrDisplay;
    if((mp.x > ad.pad.x) && (mp.x < ad.pad.x + ad.dimensions.x) && (mp.y > ad.pad.y) && (mp.y < ad.pad.y + ad.dimensions.y)){
      const linePosition = binarySearch(dom.svg.adsrLine, dom.svg.adsrLine.getTotalLength(), mousePosition);
      const addCircle = document.getElementById('addCircle');
      if(addCircle){
        addCircle.setAttribute('cx', linePosition.x);
        addCircle.setAttribute('cy', linePosition.y);
      }else{
        const circle = createCircle('addCircle', linePosition, 5, null, null, null, dom.svg.pointLayer, 'add-circle');
        circle.onclick = () => adsrAddPoint(circle);
      }
    }
  }
}

function adsrMode(mode){
  adsr.mode = mode;
  const addCircle = document.getElementById('addCircle');
  if(addCircle) addCircle.remove();
}

function adsrAddPoint(circle){
  const timeAmp = normToAmpTime({x:addCircle.getAttribute('cx'), y:addCircle.getAttribute('cy')});
  adsrDisplay.points.push({time:timeAmp.time, amp:timeAmp.amp, point:'point', line:'line'});
  adsrDisplay.points = adsrDisplay.points.sort((a, b) => a.time - b.time);
  adsrMode('move');
  saveNodeitData();
  drawAdsr();
}
function adsrRemovePoint(index){
    adsrDisplay.points.splice(index, 1);
    adsrMode('move');
    saveNodeitData();
    drawAdsr();
}

function adsrTextUpdate(){
  const point = adsr.pointList[adsr.index];
  point.time = dom.ctrl.adsrTimeText.value;
  point.amp = dom.ctrl.adsrAmplitudeText.value;
  point.point = dom.ctrl.adsrPointSelect.value;
  point.line = dom.ctrl.adsrLineSelect.value;
  saveNodeitData();
  drawAdsr();
}

function upHandlerAsdr(evt){
  const mousePosition = getMouseTransformed(evt, dom.svg.graphSvg);
  adsr.drag = false;
  drawAdsr();
  ////console.log(adsr.pointList);
  saveNodeitData();
}

function downHandlerOutput(evt, outputConnect, node, key){
  line.drag = true;
  const position = getTransformedElementPosition(outputConnect, dom.svg.graphSvg);
  sessionData.outputConnect = outputConnect;
  line.start = position;
  sessionData.currentNodeData = node;
}

function overHandlerInput(evt, inputConnect, node, key){
  if(line.drag){
    line.drag = false;
    const position = getTransformedElementPosition(inputConnect, dom.svg.graphSvg);
    line.end = position;
    const toNode = (inputConnect.dataset?.ext)? {id:`${node.id}_${inputConnect.dataset.ext}`}:node;
    connectNode(sessionData.currentNodeData, toNode, sessionData.outputConnect.dataset.param, inputConnect.dataset.param)
    updateLines();
  }
}

function removeConnections(id, key, ext){
  //e.g. m2taac1pb_oscillator
  if(ext){
    key = key.replace('1','').replace('2','');
    id = `${id}_${ext}`;
  }

  currentSound.nodes.forEach(node => {
    console.log(node.connections, node.type)
    if(key==='all'){
      node.connections = node.connections.filter(c => !(c.id === id));
    }else{
      node.connections = node.connections.filter(c => !(c.id === id && c.destParam === key));
    }
  });
  dom.svg.nodeLines.innerHTML = ''; //remove dead lines
  updateLines();
}

function downHandlerInput(id, key, ext){
  ////console.log('remove connection', id, key);
  removeConnections(id, key, ext);
}

function renameGraphNode(){
  sessionData.currentNodeData.title = dom.ctrl.graphNodeName.value;
  saveNodeitData();
  renderSound();
}

function downHandlerNodeBox(evt, node, container, title){

  dom.ctrl.graphNodeName.value = node.title;

  const mousePosition = getMouseTransformed(evt, dom.svg.graphSvg);
  box.drag = true;
  box.dragStart = node.position;
  box.dragDistance = {
    x:node.position.x - mousePosition.x,
    y:node.position.y - mousePosition.y,
    }
  sessionData.currentNodeBox = container;
  sessionData.currentNodeData = node;

  document.querySelectorAll('.selected').forEach(el => {
    el.classList.remove('selected')
  });
  title.classList.add('selected');
  box.selectedData = node;
}

function moveHandlerGraph(evt){
  const mousePosition = getMouseTransformed(evt, dom.svg.graphSvg);
  //Drag Node Boxes
  if(box.drag){
    const newPosition = {
      x: box.dragDistance.x + mousePosition.x,
      y: box.dragDistance.y + mousePosition.y
    }
    sessionData.currentNodeBox.setAttribute('x', newPosition.x);
    sessionData.currentNodeBox.setAttribute('y', newPosition.y);
    sessionData.currentNodeData.position = newPosition;
    updateConnectPoints();
  }
  //Drag Connection Lines
  if(line.drag){
    //draw a line between the output and the mouse, -3 gap clears space for mouseover on inputs
    line.end = {x:mousePosition.x-3, y:mousePosition.y-3};
    drawConnectingLine(null, 'tempLine');
  }
}

function drawConnectingLine(path, id){
  const pathData = (path)? path:`M${line.start.x} ${line.start.y} L${line.end.x} ${line.end.y}`;
  id = (id)? id:'cl_' + sessionData.currentNodeData.id;
  const connectLine = document.getElementById(id);
  if(connectLine){
    connectLine.setAttribute('d', pathData);
  }else{
    createPath(pathData, null, null, null, id, dom.svg.nodeLines, false, 'connect-line');
  }
}

function upHandlerGraph(evt){
  box.drag = false;
  line.drag = false;
  sessionData.connected = false;
  saveNodeitData();
}
// --- Sound Change and Add ---
function populateSoundSelect(){
  dom.ctrl.soundSelect.innerHTML = '<option value="" disabled>Select a sound...</option>';
  nodeData.sounds.forEach(sound => {
    const option = document.createElement('option');
    option.text = sound.title;
    option.value = sound.id;
    option.selected = (sound.id === nodeData.currentSoundId)? 'selected':'';
    dom.ctrl.soundSelect.add(option);
  });
}

function populateSongSoundSelect(){
  dom.ctrl.soundSelectAbove.innerHTML =dom.ctrl.soundSelect.innerHTML
  //dom.ctrl.songSoundSelect.innerHTML = '<option value=""></option>';
  nodeData.songs.forEach(song => {
    song.tracks.forEach(track => {
      const sound = track.sounds[0];
      const title = `${sound.title} (${song.title})`;
      console.log(title, song.id, track.id, sound.id)
      const option = document.createElement('option');
      option.text = title;
      option.value = `{"soundId":"${sound.id}","trackId":"${track.id}","songId":"${song.id}"}`;
      dom.ctrl.soundSelectAbove.add(option);
    });
  });
  dom.ctrl.soundSelectBelow.innerHTML = dom.ctrl.soundSelectAbove.innerHTML;
}

function populateRootNoteSelect(){
  dom.ctrl.rootNoteSelect.innerHTML = '<option value=""></option>';
  noteListKeys.forEach(note => {
    //console.log(note)
    const option = document.createElement('option');
    option.text = note;
    option.value = note;
    option.selected = (note === keyLastPlayed)? 'selected':'';
    dom.ctrl.rootNoteSelect.add(option);
  });
}

function populateNodeSelect(){
  const sortedObj = Object.keys(nodeLibrary).sort().reduce((acc, key) => {
      acc[key] = nodeLibrary[key];
      return acc;
  },{});

  dom.ctrl.nodeSelect.innerHTML = '<option value="" disabled selected hidden>Add Node...</option><option value="" disabled >Standard Web Audio</option>';
  Object.keys(sortedObj).forEach(key => {
    const node = sortedObj[key];
    if(!node.custom){
      const option = document.createElement('option');
      option.text = node.title;
      option.value = key;
      dom.ctrl.nodeSelect.add(option);
    }
  });
  dom.ctrl.nodeSelect.innerHTML += '<option value="" disabled >Custom</option>';
  Object.keys(nodeLibrary).forEach(key => {
    const node = nodeLibrary[key];
    if(node.custom){
      const option = document.createElement('option');
      option.text = node.title;
      option.value = key;
      dom.ctrl.nodeSelect.add(option);
    }
  });
}

function addNewSound(title){
  if(!title) title = dom.ctrl.addNewSoundInput.value;
  if(!title) title = 'New Sound'
  const exampleSound = new Sound(title);
  const osc = createUniqueNode(nodeLibrary['oscillator']);
  const adsr = createUniqueNode(nodeLibrary['adsr']);
  const gain = createUniqueNode(nodeLibrary['gain']);
  const dest = createUniqueNode(nodeLibrary['destination']);
  osc.position = {x:300, y:200};
  adsr.position = {x:570, y:350};
  gain.position = {x:850, y:200};
  dest.position = {x:1200, y:200};
  connectNode(osc, gain, 'output', 'input');
  connectNode(gain, dest, 'output', 'input');
  connectNode(adsr, gain, 'output', 'gain');
  exampleSound.nodes.push(osc);
  exampleSound.nodes.push(adsr);
  exampleSound.nodes.push(gain);
  exampleSound.nodes.push(dest);
  currentSound = exampleSound;
  nodeData.sounds.push(exampleSound);
  nodeData.currentSoundId = exampleSound.id;
  saveNodeitData();
  populateSoundSelect();
  dom.svg.nodeLines.innerHTML = '';
  renderSound();
  closeModal();
}

function cloneSound(title){
    if(!title) title = dom.ctrl.addNewSoundInput.value;
    if(!title) title = dom.ctrl.soundSelect.options[dom.ctrl.soundSelect.selectedIndex].text + '_copy'
    const newSound = cloneObject(currentSound, true);
    newSound.title = title;
    currentSound = newSound;
    nodeData.sounds.push(newSound);
    nodeData.currentSoundId = newSound.id;
    saveNodeitData();
    populateSoundSelect();
    dom.svg.nodeLines.innerHTML = '';
    renderSound();
    closeModal();
}

function findSound(soundId){
  let location = 'sound';
  dom.el.svgContainer.classList.remove('custom-sound');
  // If no id then get id from soundSelect
  const id = (soundId)? soundId:dom.ctrl.soundSelect.value;
  // Check in nodeData sounds
  let sound = nodeData.sounds.find(s => s.id === id);
  // Not found in node data look in song sounds
  if(!sound){
    if(!currentSong){
      let song = nodeData.songs.find(s => s.id === nodeData.currentSongId);
      if(!song) song = nodeData.songs[0]; //get first
      currentSong = song;
    };
    // Check in current song
    currentSong.tracks.forEach(track => {
      if(track.sounds[0].id === soundId){
       sound = track.sounds[0];
       dom.el.svgContainer.classList.add('custom-sound');
       location = 'song';
       dom.ctrl.soundSelect.value = '';
      }
    });
  }
  // Not found in song sounds
  if(!sound){
    if(currentSong?.masterBus?.id === soundId){
       sound = currentSong.masterBus;
       location = 'song';
    }
  }
  // Not found in song master bus
  if(!sound){
    if(nodeData?.masterBus?.id === soundId){
       sound = nodeData.masterBus;
    }
  }

  if(!sound) sound = nodeData.sounds[0]; //get first
  if(location === 'song') dom.el.svgContainer.classList.add('custom-sound');

  sound.location = location;
  return sound;
}

function updateSound(soundId){
  console.log(soundId);
  currentSound = findSound(soundId);
  nodeData.currentSoundId = currentSound.id;
  saveNodeitData();
  dom.svg.nodeLines.innerHTML = '';
  renderSound();
  drawAdsr();
}

function openMasterBus(){
  if(!currentSong.masterBus){
    currentSong.masterBus = createMasterBus();
  }
  updateSound(currentSong.masterBus.id);
}

function openSoundMasterBus(){
  if(!nodeData.masterBus){
    nodeData.masterBus = createMasterBus();
  }
  updateSound(nodeData.masterBus.id);
}

function addNode(){
  ////console.log(dom.ctrl.nodeSelect.value, nodeLibrary[dom.ctrl.nodeSelect.value]);
  const node = createUniqueNode(nodeLibrary[dom.ctrl.nodeSelect.value]);
  node.position = {x:10, y:230};
  currentSound.nodes.push(node);
  dom.ctrl.nodeSelect.value = '';
  renderSound();
}

function deleteNode(){
  //Confirm first!
  if(box.selectedData){
    ////console.log(box.selectedData)
    currentSound.nodes = currentSound.nodes.filter(n => n != box.selectedData);
    removeConnections(box.selectedData.id, 'all');
    saveAndRender();
  }
}

// --- Import Export ---
function exportData(data=nodeData, title='soundnode') {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  const isoDate = formatDate(new Date());
  a.href = URL.createObjectURL(blob);
  a.download = `${title}-${isoDate}.json`;
  a.click();
}

function exportAllData(){
  exportData(nodeData, 'soundnode');
  nodeData.lastSaved = formatDate(new Date());
  closeModal();
  saveNodeitData();
}

function exportSong(){exportData(currentSong, currentSong.title);}

function exportSound(){exportData(currentSound, currentSound.title);}

const importSettings = {type:null}

function setImport(type){
  importSettings.type = type;
  dom.ctrl.hiddenFileInput.click();
}

function importAllData(){setImport('all');}
function importSong(){setImport('song');}
function importSound(){setImport('sound');}

function importData(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const data = JSON.parse(e.target.result);
      const type = importSettings.type
      if(type==='all'){
        if(data.sounds){ //check for sounds
          nodeData = data;
          showToast('Imported!', 'success');
        }else{
          showToast('Sound Node data invalid format', 'error')
        }
      }else{
        data.id = generateId();
        data.title = data.title + '_imported';
        if(type==='song'){
          if(data.tracks){ //check for tracks
            nodeData.songs.push(data);
            populateSongSelect();
            showToast('Imported!', 'success');
          }else{
            showToast('Song data invalid format', 'error')
          }
        }if(type==='sound'){
          if(data.nodes){ //check for nodes
            nodeData.sounds.push(data);
            populateSoundSelect();
            showToast('Imported!', 'success');
          }else{
            showToast('Sound data invalid format', 'error')
          }
        }
      }
      saveAndRender();
    } catch (err) {
      alert('Failed to load file: Invalid format.');
    }
  };
  reader.readAsText(file);
}

// --- Save and Load ---

function saveNodeitData() {
  localStorage.setItem('nodeitData', JSON.stringify(nodeData));
}

function loadNodeitData() {
  const data = localStorage.getItem('nodeitData');
  if(data){
    const parsed = JSON.parse(data);
    nodeData = parsed;
    populateSoundSelect();
    updateSound(nodeData.currentSoundId);
    setAnimationOn(nodeData.animationOn);
    setPanelSection();
    setSidePanel();
    updateSong(nodeData.currentSongId, false);
    initSound();
  }else{
    //add starter sound
    addNewSound('beep');
    nodeData.songs.push({"title":"tmttr","musicGenre":"rock","tempo":105,"tracks":[{"title":"track1","arrangement":[{"title":"d2","frequency":73.42,"beat":1,"envelopeLength":0.5,"id":"v0akzvfa1","trackId":"zcatv0j0t"},{"title":"f2","frequency":87.31,"beat":2,"envelopeLength":0.25,"id":"zounohcnm","trackId":"zcatv0j0t"},{"title":"g2","frequency":98,"beat":2.5,"envelopeLength":0.25,"id":"pmfyohecb","trackId":"zcatv0j0t"},{"title":"c3","frequency":130.81,"beat":3,"envelopeLength":0.25,"id":"lh0d3ga0o","trackId":"zcatv0j0t"},{"title":"a2","frequency":110,"beat":3.5,"envelopeLength":0.25,"id":"jac92g1je","trackId":"zcatv0j0t"},{"title":"g2","frequency":98,"beat":4,"envelopeLength":0.25,"id":"a74di20e6","trackId":"zcatv0j0t"},{"title":"f2","frequency":87.31,"beat":5,"envelopeLength":0.5,"id":"k4dq3yqyp","trackId":"zcatv0j0t"},{"title":"g4","frequency":73.42,"beat":6,"envelopeLength":0.75,"id":"44n01gpow","trackId":"zcatv0j0t"}],"gain":0.8,"id":"zcatv0j0t","sounds":[{"title":"Fingered Bass","nodes":[{"id":"z36e4klrx","title":"Oscillator","type":"oscillator","position":{"x":243,"y":1},"connections":[{"id":"tw4gb2qf2","startParam":"output","destParam":"input"}],"parameters":{"type":{"value":"sawtooth","param":"type","label":"Type","ext":""},"frequency":{"value":"120","param":"frequency","label":"Frequency","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}},"lfo":false},{"id":"tw4gb2qf2","title":"Gain","type":"gain","position":{"x":753,"y":98},"connections":[{"id":"vlre4mcp6","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.4","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"rmnc35x5k","title":"Destination","type":"destination","position":{"x":1651,"y":100},"connections":[],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""}}},{"id":"4x9tszzoj","title":"Oscillator","type":"oscillator","position":{"x":242,"y":189},"connections":[{"id":"9xf9uknn2","startParam":"output","destParam":"input"}],"parameters":{"type":{"value":"square","param":"type","label":"Type","ext":""},"frequency":{"value":"120","param":"frequency","label":"Frequency","ext":""},"detune":{"value":"0","param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}},"lfo":false},{"id":"9xf9uknn2","title":"Gain","type":"gain","position":{"x":755,"y":290},"connections":[{"id":"vlre4mcp6","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.4","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"vlre4mcp6","title":"Gain","type":"gain","position":{"x":1068,"y":101},"connections":[{"id":"g3lcxaf79","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.5","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"g3lcxaf79","title":"Filter","type":"filter","position":{"x":1359,"y":98},"connections":[{"id":"rmnc35x5k","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"type":{"value":"lowpass","param":"type","label":"Type","ext":""},"frequency":{"value":"400","param":"frequency","label":"Frequency","ext":""},"Q":{"value":1,"param":"Q","label":"Q","ext":""},"gain":{"value":0.5,"param":"gain","label":"Gain","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"656vs3a6d","title":"ADSR","type":"adsr","position":{"x":246,"y":372},"connections":[{"id":"9xf9uknn2","startParam":"output","destParam":"gain"},{"id":"tw4gb2qf2","startParam":"output","destParam":"gain"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":0,"amp":0.001,"point":"point","line":"line"},{"time":0.022,"amp":0.926,"point":"point","line":"curve"},{"time":0.889,"amp":0,"point":"point","line":"line"},{"time":0.947,"amp":0,"point":"point","line":"line"},{"time":1,"amp":0,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":0,"param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":1,"param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}}],"settings":[],"id":"1l1okrfay"}],"virtualArrangement":[],"loop":{"mode":"off","start":0,"end":0,"qty":0},"on":true},{"title":"track2","arrangement":[{"title":"d2","frequency":73.42,"beat":1,"envelopeLength":0.5,"id":"lba0k1oie","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":2,"envelopeLength":0.25,"id":"xljzpwqfj","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":3,"envelopeLength":0.25,"id":"plyrtqbgv","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":4,"envelopeLength":0.25,"id":"94u5afit9","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":5,"envelopeLength":0.25,"id":"amxwaymf9","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":6,"envelopeLength":0.25,"id":"x2c3q1r7m","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":7,"envelopeLength":0.25,"id":"1hyxmfenn","trackId":"oxz89112y"},{"title":"d2","frequency":73.42,"beat":8,"envelopeLength":0.25,"id":"gkd18gtgv","trackId":"oxz89112y"},{"title":"c4","frequency":440,"beat":9,"envelopeLength":0.25,"id":"e0pmtv34b","trackId":"oxz89112y"}],"gain":0.8,"id":"oxz89112y","sounds":[{"title":"Kick Drum","nodes":[{"id":"d5sj03wex","title":"Oscillator","type":"oscillator","position":{"x":351,"y":25},"connections":[{"id":"nbfv67bmt","startParam":"output","destParam":"input"}],"parameters":{"type":{"value":"sine","param":"type","label":"Type","ext":""},"frequency":{"value":"140","param":"frequency","label":"Frequency","ext":""},"detune":{"value":"0","param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}},"lfo":false},{"id":"nbfv67bmt","title":"Gain","type":"gain","position":{"x":939,"y":66},"connections":[{"id":"qfwccmdwk","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.5","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"x031ve5dq","title":"Destination","type":"destination","position":{"x":1560,"y":91},"connections":[],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""}}},{"id":"qfwccmdwk","title":"Filter","type":"filter","position":{"x":1210,"y":70},"connections":[{"id":"x031ve5dq","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"type":{"value":"lowpass","param":"type","label":"Type","ext":""},"frequency":{"value":"800","param":"frequency","label":"Frequency","ext":""},"Q":{"value":1,"param":"Q","label":"Q","ext":""},"gain":{"value":0.5,"param":"gain","label":"Gain","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"hehs3kng8","title":"ADSR","type":"adsr","position":{"x":650,"y":183},"connections":[{"id":"nbfv67bmt","startParam":"output","destParam":"gain"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":"0.003","amp":"0","point":"point","line":"line"},{"time":"0.01","amp":"0.988","point":"point","line":"curve"},{"time":0.344,"amp":0.001,"point":"point","line":"curve"},{"time":0.894,"amp":0,"point":"point","line":"line"},{"time":0.997,"amp":0.001,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":"0","param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":"1","param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"30ru8bjhr","title":"ADSR","type":"adsr","position":{"x":61,"y":93},"connections":[{"id":"d5sj03wex","startParam":"output","destParam":"detune"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":0.003,"amp":0.001,"point":"point","line":"line"},{"time":0.481,"amp":0.997,"point":"point","line":"line"},{"time":0.561,"amp":0.993,"point":"point","line":"line"},{"time":0.781,"amp":0.993,"point":"point","line":"line"},{"time":1,"amp":0.993,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":"0","param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":"-4000","param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}}],"settings":[],"id":"xtuf6qcfn"}],"virtualArrangement":[],"loop":{"mode":"off","start":0,"end":0,"qty":0},"on":true},{"title":"track3","arrangement":[{"title":"a4","beat":1.5,"envelopeLength":1.5,"id":"6asp7io1n","trackId":"mpdfow234"},{"title":"a4","frequency":440,"beat":7,"envelopeLength":1,"id":"j715z0ylf","trackId":"mpdfow234"}],"gain":0.8,"id":"mpdfow234","sounds":[{"title":"Snare Drum","nodes":[{"id":"6x826ylfc","title":"Gain","type":"gain","position":{"x":1027,"y":21},"connections":[{"id":"vbqqnrgus","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.7","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"vbqqnrgus","title":"Destination","type":"destination","position":{"x":1361,"y":24},"connections":[],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""}}},{"id":"isioatdm7","title":"Noise","type":"noise","position":{"x":401,"y":10},"connections":[{"id":"nv56uu56o","startParam":"output","destParam":"input"}],"parameters":{"playbackRate":{"value":1,"param":"playbackRate","label":"PlaybackRate","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"nv56uu56o","title":"Filter","type":"filter","position":{"x":672,"y":9},"connections":[{"id":"6x826ylfc","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"type":{"value":"highpass","param":"type","label":"Type","ext":""},"frequency":{"value":"9000","param":"frequency","label":"Frequency","ext":""},"Q":{"value":1,"param":"Q","label":"Q","ext":""},"gain":{"value":0.5,"param":"gain","label":"Gain","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"ik3uu90qv","title":"ADSR","type":"adsr","position":{"x":400,"y":160},"connections":[{"id":"6x826ylfc","startParam":"output","destParam":"gain"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":0,"amp":0.909,"point":"point","line":"line"},{"time":0.067,"amp":0.58,"point":"point","line":"line"},{"time":0.122,"amp":0.043,"point":"point","line":"line"},{"time":0.461,"amp":0,"point":"point","line":"line"},{"time":0.95,"amp":0.001,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":0,"param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":1,"param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"lnsblmd0b","title":"Oscillator","type":"oscillator","position":{"x":397,"y":516},"connections":[{"id":"zptyy6gx2","startParam":"output","destParam":"input"}],"parameters":{"type":{"value":"triangle","param":"type","label":"Type","ext":""},"frequency":{"value":440,"param":"frequency","label":"Frequency","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}},"lfo":false},{"id":"zptyy6gx2","title":"Gain","type":"gain","position":{"x":1030,"y":328},"connections":[{"id":"vbqqnrgus","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"0.7","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"zwdewr4dt","title":"ADSR","type":"adsr","position":{"x":671,"y":321},"connections":[{"id":"zptyy6gx2","startParam":"output","destParam":"gain"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":"0","amp":"0.7","point":"point","line":"line"},{"time":0.092,"amp":0.172,"point":"point","line":"line"},{"time":0.175,"amp":0,"point":"point","line":"line"},{"time":0.808,"amp":0,"point":"point","line":"line"},{"time":0.95,"amp":0.001,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":0,"param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":1,"param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}}],"settings":[],"id":"bjk9dexk3"}],"virtualArrangement":[],"loop":{"mode":"off","start":0,"end":0,"qty":0},"on":true},{"title":"track4","arrangement":[{"title":"a4","beat":3,"envelopeLength":1,"id":"srtu0lzt9","trackId":"jonlf9pbw"},{"title":"g4","frequency":440,"beat":5,"envelopeLength":1,"id":"glhherkkn","trackId":"jonlf9pbw"},{"title":"a4","frequency":440,"beat":8.5,"envelopeLength":0.5,"id":"qhejmpkwk","trackId":"jonlf9pbw"}],"gain":0.8,"id":"jonlf9pbw","sounds":[{"title":"Hi Hat","nodes":[{"id":"6x826ylfc","title":"Gain","type":"gain","position":{"x":1027,"y":21},"connections":[{"id":"vbqqnrgus","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"gain":{"value":"1","param":"gain","label":"Gain","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"vbqqnrgus","title":"Destination","type":"destination","position":{"x":1361,"y":24},"connections":[],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""}}},{"id":"isioatdm7","title":"Noise","type":"noise","position":{"x":300,"y":160},"connections":[{"id":"nv56uu56o","startParam":"output","destParam":"input"}],"parameters":{"playbackRate":{"value":1,"param":"playbackRate","label":"PlaybackRate","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"nv56uu56o","title":"Filter","type":"filter","position":{"x":672,"y":9},"connections":[{"id":"6x826ylfc","startParam":"output","destParam":"input"}],"parameters":{"input":{"value":"io","param":"input","label":"Input","ext":""},"type":{"value":"highpass","param":"type","label":"Type","ext":""},"frequency":{"value":"9000","param":"frequency","label":"Frequency","ext":""},"Q":{"value":1,"param":"Q","label":"Q","ext":""},"gain":{"value":0.5,"param":"gain","label":"Gain","ext":""},"detune":{"value":0,"param":"detune","label":"Detune","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}},{"id":"ik3uu90qv","title":"ADSR","type":"adsr","position":{"x":672,"y":309},"connections":[{"id":"6x826ylfc","startParam":"output","destParam":"gain"}],"parameters":{"duration":{"value":2,"param":"duration","label":"Duration","ext":""},"points":{"value":[{"time":0,"amp":0.909,"point":"point","line":"line"},{"time":0.067,"amp":0.58,"point":"point","line":"line"},{"time":0.114,"amp":0.151,"point":"point","line":"line"},{"time":0.542,"amp":0,"point":"point","line":"line"},{"time":0.95,"amp":0.001,"point":"point","line":"line"}],"param":"points","label":"ADSR Points","ext":"","display":"none"},"ampMin":{"value":0,"param":"ampMin","label":"Amp Min","ext":""},"ampMax":{"value":1,"param":"ampMax","label":"Amp Max","ext":""},"output":{"value":"io","param":"output","label":"Output","ext":""}}}],"settings":[],"id":"m07wmm952"}],"virtualArrangement":[],"loop":{"mode":"off","start":0,"end":0,"qty":0},"on":true}],"id":"q7kktztqn"});
    updateSong(nodeData.songs[0].id);
    initSound();

  }
}

// --- Initialization ---
function initDomReferences(){
  //Populate dom object with elements that match classnames e.g. dom-svg
  const domList = ['svg','el','ctrl','btn'];
  domList.forEach(ref => {
    document.querySelectorAll(`.dom-${ref}`).forEach(el =>{
      dom[ref][el.id] = document.getElementById(el.id);
    });
  });

  dom.svg.graphSvg.addEventListener("mousemove", moveHandlerGraph, false);
  dom.svg.graphSvg.addEventListener("mouseup", upHandlerGraph, false);
  dom.svg.graphSvg.addEventListener("onleave", upHandlerGraph, false);

  dom.svg.adsrSvg.addEventListener("mousemove", moveHandlerAsdr, false);
  dom.svg.adsrSvg.addEventListener("mouseup", upHandlerAsdr, false);
  dom.svg.adsrSvg.addEventListener("onleave", upHandlerAsdr, false);

  dom.ctrl.soundSelect?.addEventListener('change', () => updateSound(null));
  dom.ctrl.nodeSelect?.addEventListener('change', addNode);

  dom.ctrl.adsrAmplitudeText?.addEventListener('input', adsrTextUpdate);
  dom.ctrl.adsrTimeText?.addEventListener('input', adsrTextUpdate);
  dom.ctrl.adsrPointSelect?.addEventListener('change', adsrTextUpdate);
  dom.ctrl.adsrLineSelect?.addEventListener('change', adsrTextUpdate);
  //dom.ctrl.modeSelect?.addEventListener('change', () => changeModeOrDuration());

  dom.btn.toggleSidePanelButton?.addEventListener('click', () => setSidePanel(true));

  //Import Export Json Data
  document.getElementById('exportDataButton')?.addEventListener('click', exportAllData);
  const importDataButton = document.getElementById('importDataButton');
  //const hiddenFileInput = document.getElementById('hiddenFileInput');
  importDataButton?.addEventListener('click', importAllData);
  dom.ctrl.hiddenFileInput.addEventListener('change', importData);
}

// --- Soundit ---
const svgData = {beatScale:100, zoom:100, panUp:0, panLeft:0, width:0, height:0};
const trackDrag = {drag:false, noteBoxId:null, position:{x:0, y:0}, type:null};
const scales = {
  // Standard scales
  majorScaleSemitones:        [0, 2, 4, 5, 7, 9, 11, 12],  // Ionian
  minorScaleSemitones:        [0, 2, 3, 5, 7, 8, 10, 12],  // Natural minor / Aeolian
  diatonicScaleSemitones:     [0, 2, 4, 5, 7, 9, 11, 12],  // Alias of major
  // Pentatonic
  majorPentatonicSemitones:   [0, 2, 4, 7, 9],
  minorPentatonicSemitones:   [0, 3, 5, 7, 10],
  // Blues
  bluesScaleSemitones:        [0, 3, 5, 6, 7, 10, 12], // Common minor blues
  majorBluesScaleSemitones:   [0, 2, 3, 4, 7, 9, 12],
  // Modes of the major scale
  ionianScaleSemitones:       [0, 2, 4, 5, 7, 9, 11, 12], // Major
  dorianScaleSemitones:       [0, 2, 3, 5, 7, 9, 10, 12], // Minor with raised 6th
  phrygianScaleSemitones:     [0, 1, 3, 5, 7, 8, 10, 12], // Minor with flat 2nd
  lydianScaleSemitones:       [0, 2, 4, 6, 7, 9, 11, 12], // Major with raised 4th
  mixolydianScaleSemitones:   [0, 2, 4, 5, 7, 9, 10, 12], // Major with flat 7th
  aeolianScaleSemitones:      [0, 2, 3, 5, 7, 8, 10, 12], // Natural minor
  locrianScaleSemitones:      [0, 1, 3, 5, 6, 8, 10, 12], // Diminished, unstable
  // ---------------------------
  // Indian Raga approximations
  // ---------------------------
  // Note: Real ragas may have asymmetric ascending/descending forms.
  // These are equal-tempered approximations for use in synths.
  ragaBhairavSemitones:       [0, 1, 4, 5, 7, 8, 11, 12], // flat 2 & 6
  ragaBhairaviSemitones:      [0, 1, 3, 5, 7, 8, 10, 12], // natural minor + flat 2
  ragaTodiSemitones:          [0, 1, 3, 6, 7, 8, 11, 12], // tense, exotic
  ragaYamanSemitones:         [0, 2, 4, 6, 7, 9, 11, 12], // like Lydian
  ragaKafiSemitones:          [0, 2, 3, 5, 7, 9, 10, 12], // Dorian-like
  ragaDeshSemitones:          [0, 2, 4, 5, 7, 9, 10, 12], // Mixolydian flavor
  ragaHamsadhwaniSemitones:   [0, 2, 4, 7, 11, 12],       // bright, 5-note scale
  // ---------------------------
  // Middle Eastern Maqam scales
  // ---------------------------
  // These are 12-TET approximations of maqamat.
  maqamHijazSemitones:        [0, 1, 4, 5, 7, 8, 11, 12], // Phrygian dominant
  maqamBayatiSemitones:       [0, 1, 3, 5, 7, 8, 10, 12], // flat 2 & 6, minorish
  maqamNahawandSemitones:     [0, 2, 3, 5, 7, 8, 11, 12], // harmonic minor flavor
  maqamRastSemitones:         [0, 2, 4, 6, 7, 9, 10, 12], // between major & mixolydian
  maqamKurdSemitones:         [0, 1, 3, 5, 7, 8, 10, 12], // natural minor with flat 2
  /*
  Indian Ragas: Think of each as a mood + time of day + emotional color.
  Yaman (evening, devotion), Bhairav (dawn, seriousness), Kafi (romantic).
  Each raga has its own ornamentation rules  slides, bends, gamakas  that give it life.

  Maqamat: Arabic, Turkish, and Persian modal systems.
  The scale is just a skeleton; phrasing and microtonal intervals (e.g. 3/4-tones) give them their haunting depth.
  Hijaz is instantly recognizable in film and rock fusion for its augmented second.
 */

  //Exotic / Colourful Scales
  wholeTone:[0, 2, 4, 6, 8, 10, 12],  //dreamy, Debussy-ish; no semitones at all.
  chromatic:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],  //every note; good for debugging.
  hungarianMinor:[0, 2, 3, 6, 7, 8, 11, 12],  //dramatic, exotic minor feel.
  japaneseInSen: [0, 1, 5, 7, 10, 12],  //sparse and haunting.
}

const chords = {
  //single note
  note: [0],
  //Basic Intervals (from root = 0) (2 notes)
  iminor2nd: [0, 1],
  imajor2nd: [0, 2],
  iminor3rd: [0, 3],
  imajor3rd: [0, 4],
  iperfect4th: [0, 5],
  itritone: [0, 6],
  iperfect5th: [0, 7],
  iminor6th: [0, 8],
  imajor6th: [0, 9],
  iminor7th: [0, 10],
  imajor7th: [0, 11],
  ioctave: [0, 12],
  //Triads  (3 notes)
  tmajor: [0, 4, 7],
  tminor: [0, 3, 7],
  tdiminished:[0, 3, 6],
  taugmented: [0, 4, 8],
  tsuspended2nd: [0, 2, 7],
  tsuspended4th: [0, 5, 7],
  //Third Up an octave
  tUpMajor: [0, 16, 7], //12 + 4 [0, 4, 7]
  tUpMinor: [0, 15, 7], //12 + 3 [0, 3, 7]
  // Seventh Chords (4 notes)
  smajor7th: [0, 4, 7, 11],
  sdominant7th: [0, 4, 7, 10],
  sminor7th: [0, 3, 7, 10],
  shalfDiminished: [0, 3, 6, 10],
  sdiminished7th: [0, 3, 6, 9],
  sminorMajor7th: [0, 3, 7, 11],
  //ExtendedChords (5-6 notes)
  ext9th: [0, 4, 7, 10, 14],
  extmajor9th: [0, 4, 7, 11, 14],
  extminor9th: [0, 3, 7, 10, 14],
  ext11th: [0, 4, 7, 10, 14, 17],
  ext13th: [0, 4, 7, 10, 14, 21],
  // Color Chords (4 notes)
  coloradd9: [0, 4, 7, 14],
  color6th: [0, 4, 7, 9],
  colorminor6th: [0, 3, 7, 9],
  color7sus4: [0, 5, 7, 10],
};

const periodicWavePresets = [
 {title: 'blank', real: [0, 0, 0, 0, 0, 0, 0, 0, 0], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'sine1', real: [0, 1, 0, 0, 0, 0, 0, 0, 0], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'sawtooth1', real: [0, 1.0, 0.5, 0.33, 0.25, 0.2, 0.17, 0.14, 0.12], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'sawtooth2', real:[0, 0, 0, 0, 0, 0, 0, 0, 0], imaginary: [0, 1.0, 0.5, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8] },
 {title: 'square1', real: [0, 1.0, 0, 0.33, 0, 0.2, 0, 0.14, 0], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'square2', real:[0, 0, 0, 0, 0, 0, 0, 0, 0], imaginary: [0, 1.0, 0, 1/3, 0, 1/5, 0, 1/7, 0] },
 {title: 'triangle', real: [0, 1.0, 0, -1/9, 0, 1/25, 0, -1/49, 0], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'triangle2', real:[0, 0, 0, 0, 0, 0, 0, 0, 0], imaginary: [0, 1.0, 0, -1/9, 0, 1/25, 0, -1/49, 0] },
 {title: 'flute', real: [0, 1.0, 0.5, 0.25, 0.1, 0.05, 0, 0, 0], imaginary: [0, 0.02, 0.03, 0.02, 0.01, 0.005, 0, 0, 0] },
 {title: 'clarinet', real: [0, 1.0, 0, 0.6, 0, 0.3, 0, 0.15, 0], imaginary: [0, 0.1, 0, 0.05, 0, 0.02, 0, 0.01, 0] },
 {title: 'brass', real: [0, 1.0, 0.9, 0.6, 0.4, 0.3, 0.15, 0.1, 0.05], imaginary: [0, 0.1, 0.05, 0.02, 0.01, 0.005, 0, 0, 0] },
 {title: 'string', real: [0, 1.0, 0.8, 0.6, 0.5, 0.3, 0.2, 0.15, 0.1], imaginary: [0, 0.05, 0.03, 0.02, 0.01, -0.02, -0.03, 0.01, 0] },
 {title: 'organ', real: [0, 1.0, 0.8, 0.6, 0.4, 0.3, 0.2, 0.1, 0.05], imaginary: [0, 0, 0, 0, 0, 0, 0, 0, 0] },
 {title: 'bell', real: [0, 1.0, 0.8, 0.5, 0.3, 0.1, 0.05, 0.02, 0.01], imaginary: [0, 0.6, 0.4, 0.25, 0.12, 0.05, 0.03, 0.02, 0.01] },
 {title: 'sitar', real: [0, 1.0, 0.7, 0.5, 0.35, 0.25, 0.18, 0.12, 0.08], imaginary: [0, 0.2, 0.1, 0.05, -0.08, -0.12, 0.1, 0.05, 0.02] },
 {title: 'theremin', real: [0, 1.0, 0.2, 0.1, 0.05, 0.02, 0.01, 0, 0], imaginary: [0, 0.05, 0.03, 0.02, 0.01, 0.005, 0.002, 0, 0] },
 {title: 'pulse', real: [0, -0.318, 0, 0.106, 0, -0.064, 0, 0.045, 0 ], imaginary: [0, 0.318,-0.318, 0.106, 0, 0.064, -0.106, 0.045, 0] },
 {title: 'pulse05', real:[0,0,0,0,0,0,0,0,0], imaginary:[0,0.637,0,0.212,0,0.127,0,0.091,0] },
];

// --- Set Up Or Change Context or Master Settings ---
function setupMasterCompressorandGain(){
  console.log(currentSound, currentSound.location);
  const sound = currentSound;

  if(currentSound.location==='song'){
    if(!currentSong.masterBus) currentSong.masterBus = createMasterBus();
    currentSound = currentSong.masterBus;
  }else{
    if(!nodeData.masterBus) nodeData.masterBus = createMasterBus();
    currentSound = nodeData.masterBus;
  }

  buildGraph(generateId(), 'a4', null, null);

  // Set back to sound
  currentSound = sound;
}

function changeMasterGain(){
  nodeData.masterGain = dom.ctrl.masterGainRange.valueAsNumber/100;
  masterGain.gain.value = nodeData.masterGain;
  saveNodeitData();
}

function createOffline(duration = 4){ // seconds
  //console.log('createOffline', duration);
  const sampleRate = 48000; //very high
  const numberOfChannels = 2
  return new window.OfflineAudioContext(numberOfChannels, sampleRate * duration, sampleRate);
}

// This could be constructed
function createMasterBus(){
  const sound = new Sound("Master Bus");
  let mixData = [
    {type:'allnodes', pos: {x:170, y:225}, id:generateId()},
    {type:'dynamicsCompressor', pos: {x:555, y:135}, id:generateId()},
    {type:'gain', pos: {x:970, y:155}, id:generateId()},
    {type:'destination', pos: {x:1310, y:155}, id:generateId()}
  ];
  mixData.forEach((item, index) =>{
    const node = createUniqueNode(nodeLibrary[item.type]);
    //node = cloneObject(node)
    node.position = item.pos;
    node.id = item.id;
    if(index!=mixData.length-1){ //not on last
      node.connections = [{id:mixData[index+1].id, startParam:'output', destParam:'input'}];
    }
    sound.isMasterBus = true;
    sound.nodes.push(node);
  });
  //const mixTrack = new Track('Mix Track', [sound]);
  //mixTrack.arrangement = [];
  //mixTrack.isMixTrack = true;
  return sound
}

// --- Constructor Functions ---
 function Song(title, musicGenre, tempo, tracks, id){
  this.title = title || '';
  this.musicGenre = musicGenre || '';
  this.tempo = tempo || 105;
  this.tracks = tracks || [];
  //this.mixTrack = createNewMixTrack();
  this.masterBus = createMasterBus();
  this.id = id || generateId();
 }

 function Track(title, sounds, arrangement, loop, gain, id){
  this.title = title || 'track';
  this.sounds = sounds || [cloneObject(currentSound, true)];
  this.arrangement = arrangement || [new Note()];
  this.virtualArrangement = [];
  this.loop = loop || {mode:'off', start:1, end:2, qty:1};
  this.gain = gain || 0.8;
  this.on = true; //start with on to prevent confusion
  this.mute = false;
  this.id = id || generateId();
  //this.isMixTrack = false;
  this.color = null;
 }

 function Note(title, beat, envelopeLength, chord, id){
  this.title = title || 'a4';
  this.frequency = noteList[title];
  this.beat = beat || 1;
  this.envelopeLength = envelopeLength || 1;
  this.chord = chord || 'note';
  this.id = id || generateId();
 }

// --- Helper Functions ---
function calculateDistance(pos1,pos2,positiveOnly){
  const a = Number(pos1.x) - Number(pos2.x);
  const b = Number(pos1.y) - Number(pos2.y);
  let ans = Math.sqrt(a*a + b*b)
  if(positiveOnly){ans = Math.abs(ans)}
  if(isNaN(ans)) ans=10000;
  return ans;
}

function findSnap(xpos, snapWidth=25, accuracy=6){
  nodeData.snap = true;
  if(!nodeData.snap) return xpos;
  //Calculate if close to multiples of 25
  //const fits = snapWidth * xpos/snapWidth;
  const fits = snapWidth * Math.round(xpos/snapWidth);
  //return (Math.abs(xpos - fits)<accuracy)? fits:xpos;
  return fits;
}

function toggleSnap(){
  nodeData.snap = !nodeData.snap;
}

function createNoteBox(pos, width, note, layer, trackId){
  pos.y -= 5;
  note.trackId = trackId;
  //if note is a selected note
  const selected = (selectedNotes.includes(note.id))? ' note-select':'';
  const rect = createRect2(note.id, pos, width, null, null, null, layer, 'dom-note note-box box-color' + selected);
  dom.notes[note.id] = rect;
  const textPos = {x:pos.x + (width/2), y:pos.y + 10}
  createText('text_' + note.id, textPos, null, layer, note.title, 'note-box-text');
  //rect.onclick = () => noteBoxSelect(rect, pos, layer, width, note);
  rect.onmousedown = () => noteBoxDownhandler(rect, pos, layer, width, note, trackId)
}

function createNoteBoxVirtual(pos, width, note, layer, trackId){
  note.trackId = trackId;
  pos.y += 20;
  const rect = createRect2(note.id, pos, width, null, null, null, layer, 'dom-note note-box-virtual box-color');
  dom.notes[note.id] = rect;
  const textPos = {x:pos.x + (width/2), y:pos.y + 10}
  createText('text_' + note.id, textPos, null, layer, note.title, 'note-box-virtual-text');
}

function loopSelect(box, track, loopStart, loopWidth){
  //console.log(box, track, loopStart, loopWidth);
  loopBox.drag = true;
  loopBox.info = {box, track, start:loopStart, width:loopWidth};
  document.querySelectorAll('.loop-select').forEach(item => {
    item.classList.remove('loop-select');
  });
  box.classList.add('loop-select');
}

function noteBoxDownhandler(box, pos, layer, width, note, trackId){
  if(selectedNotes.length!=0){
   console.log('selectedNotes', selectedNotes, note.id, trackId);
   selNote.drag = true;
  }else{
   noteBoxSelect(box, pos, layer, width, note, trackId)
  }
}

function noteBoxSelect(box, pos, layer, width, note, trackId){
  selectedNotes = [note.id];
  //console.log('notebox', box, pos, layer, width, note, trackId)
  if(trackDrag.drag) return; //if dragging do not change points
  //if(currentNoteBox?.id === note.id) return;
  console.log('pass');
  currentNote = note;
  currentNoteBox = box;
  document.querySelectorAll('.note-select').forEach(item => {
    item.classList.remove('note-select');
  });

  box.classList.add('note-select');
  const trackTranslation = Number(layer.dataset.translatey);

  const dragStartPosition = {x:pos.x, y:pos.y + 10}; //height is 20 so 10 is center
  const dragEndPosition = {x:dragStartPosition.x, y:dragStartPosition.y};
  dragEndPosition.x += width;

  let dragStart= document.getElementById('dragStart')
  if(dragStart) dragStart.remove();
  dragStart = createCircle('dragStart', dragStartPosition, 5, null, null, null, layer, 'drag-circle');
  dragStart.dataset.id = note.id;
  dragStart.onmouseover = () => dragCircleOver(note.id, dragStartPosition, trackTranslation, width, 'start', );

  let dragEnd = document.getElementById('dragEnd')
  if(dragEnd) dragEnd.remove();
  dragEnd = createCircle('dragEnd', dragEndPosition, 5, null, null, null, layer, 'drag-circle');
  dragEnd.dataset.id = note.id;
  dragEnd.onmouseover = () => dragCircleOver(note.id, dragEndPosition, trackTranslation, width, 'end');
}

// --- SVG Functions ---
function createGroup(id, yAdjust, layer, className){
  const group = document.createElementNS(svgns, "g");
  group.setAttributeNS(null, 'id', id);
  group.setAttributeNS(null, 'class', className);
  group.setAttributeNS(null, 'transform', `translate(0 ${yAdjust})`);
  group.setAttributeNS(null, 'data-translatey', yAdjust);
  layer.appendChild(group);
  return group;
}

function createText(id, pos, fill, layer, textStr, className){
  const text = document.createElementNS(svgns, 'text');
  if(id) text.setAttributeNS(null, 'id', id);
  text.setAttributeNS(null, 'class', className);
  text.setAttributeNS(null, 'x', pos.x);
  text.setAttributeNS(null, 'y', pos.y);
  if(fill) text.setAttributeNS(null, 'style', 'fill:' + fill + ';');
  text.textContent = textStr;
  layer.appendChild(text);
}

function createRect2(id, pos, width, fill, stroke, strokeWidth, layer, className){
  width = Math.abs(width);
  const rect = document.createElementNS(svgns, 'rect');
  if(id) rect.setAttributeNS(null, 'id', id);
  if(className!=null) rect.setAttributeNS(null, 'class', className);
  rect.setAttributeNS(null, 'width', width)
  rect.setAttributeNS(null, 'x', pos.x);
  rect.setAttributeNS(null, 'y', pos.y);
  if(fill) rect.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';');
  if(layer) layer.appendChild(rect);
  return rect;
}

function dragCircleOver(id, position, trackTranslation, width, type){
  if(trackDrag.drag) return; //if dragging do not change points
  trackDrag.noteBoxId = id;
  trackDrag.position = {x:position.x, y:position.y + trackTranslation};
  trackDrag.type = type;
  trackDrag.width = width;
}

function changeZoom(panUp=0){
  const songDuration = calculateSongDuration();
  const trackWidth = (Math.ceil(songDuration/beatDuration) * 100) - 700;
  let panLeft = Number(dom.ctrl.panLeftRange.value)/100;
  currentSong.zoom = Number(dom.ctrl.zoomRange.value)/100;
  currentSong.pan = panLeft * trackWidth;
  svgData.panUp += Math.floor(panUp);
  const newHeight = svgData.height / currentSong.zoom;
  const newWidth = svgData.width / currentSong.zoom;
  dom.svg.tracksSvg.setAttribute("viewBox", `${currentSong.pan} ${svgData.panUp} ${newWidth} ${newHeight}`);
  updateFixedPosition();
  saveNodeitData();
}

function changeSoundZoom(){
  const width = 1873;
  const height = 701;
  currentSound.zoom = Number(dom.ctrl.soundZoomRange.value)/100;
  const newWidth = width / currentSound.zoom;
  const newHeight = height / currentSound.zoom;
  dom.svg.graphSvg.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);
  saveNodeitData();
}

function resetSoundZoom(){
  dom.ctrl.soundZoomRange.value = 100;
  changeSoundZoom()
}

function tracksHeight(){
  const scaledHeight = screenToSvg(dom.svg.tracksSvg, 100);
  let height = currentSong.tracks.length * scaledHeight.x;
  if(height<300) height = 300;
  //console.log(scaledHeight.x, currentSong.tracks.length);
  return height;
}

function changeBarView(num){
  const scale = {'4':1, '8':1.25, '16':1.5}
  const scaleNum = scale[num];
  const newWidth = 100/num;

  // Change the grid
  dom.svg.beatLineSmall.setAttribute('width', newWidth);

  // Change the zoom
  const svgHeight = tracksHeight();
  const svgWidth = tracksSvg.getAttribute('width');

  dom.ctrl.zoomRange.value = scaleNum * 100;

  svgData.height = svgHeight * scaleNum;
  svgData.width = svgWidth * scaleNum;

  tracksSvg.setAttribute('height', svgData.height);
  tracksSvg.setAttribute('width', svgData.width);
  //tracksSvg.setAttribute('height', yAdjust);
  tracksSvg.setAttribute('viewBox', `0 0 ${svgWidth/scaleNum} ${svgHeight/scaleNum}`);

  // Update snap threshold
  timeLine.snap.width = newWidth;
  timeLine.snap.distance = newWidth/2.5;
}

function resetZoom(){
  dom.ctrl.zoomRange.value = 100;
  dom.ctrl.panLeftRange.value = 0;
  changeZoom();
}

function updateFixedPosition() {
  const pos = screenToSvg(dom.svg.tracksSvg, 16);
  document.querySelectorAll('.track-controls').forEach(fixedElem =>{
    fixedElem.setAttribute("x", pos.x);
  });
}

function screenToSvg(svg, screenX, screenY = 0) {
  const pt = svg.createSVGPoint();
  pt.x = screenX;
  pt.y = screenY;
  return pt.matrixTransform(svg.getScreenCTM().inverse());
}

function changeSelect(x, y, width, height, visible='visible'){
  dom.svg.selection.setAttribute('x',x);
  dom.svg.selection.setAttribute('y', y);
  dom.svg.selection.setAttribute('width', width);
  dom.svg.selection.setAttribute('height', height);
  dom.svg.selection.setAttribute('visibility', visible);
}

function getGlobalBox(elem, svg) {
  const pt = svg.createSVGPoint();

  function transformPoint(x, y) {
    pt.x = x; pt.y = y;
    return pt.matrixTransform(elem.getScreenCTM());
  }

  const box = elem.getBBox();
  const p1 = transformPoint(box.x, box.y);
  const p2 = transformPoint(box.x + box.width, box.y + box.height);

  return {
    x: Math.min(p1.x, p2.x),
    y: Math.min(p1.y, p2.y),
    width: Math.abs(p2.x - p1.x),
    height: Math.abs(p2.y - p1.y)
  };
}

function selectNotes(){
  selectedNotes = [];
  selNote.notes = {};
  //const sel = dom.svg.selection.getBBox();
  const sel = getGlobalBox(dom.svg.selection, dom.svg.tracksSvg);
  //console.log(sel)
  document.querySelectorAll("#tracksSvg .note-box").forEach(rect => {
    //const box = rect.getBBox();
    const box = getGlobalBox(rect, dom.svg.tracksSvg);
    const inside =
      box.x >= sel.x &&
      box.y >= sel.y &&
      box.x + box.width <= sel.x + sel.width &&
      box.y + box.height <= sel.y + sel.height;

    rect.classList.toggle("note-select", inside);
    if(inside){
      selectedNotes.push(rect.id);
      //create and obj lib of selected notes
      currentSong.tracks.forEach(track => {
        track.arrangement.forEach(note => {
          if(note.id === rect.id){
            selNote.notes[rect.id] = {note:note, r:rect, x:box.x};
          }
        });
      });
    }
  });

 // console.log(selNote);
  changeSelect(0, 0, 0, 0, 'hidden')
}

//Time
function downHandlerTime(evt){
  const mousePosition = getMouseTransformed(evt, tracksSvg);
  timeLine.drag = true;
  //console.log(dom.svg.timeDrag0, dom.svg.timeDrag1)
  const timeDrag0Pos = getTransformedElementPosition(dom.svg.timeDrag0, dom.svg.tracksSvg);
  const timeDrag1Pos = getTransformedElementPosition(dom.svg.timeDrag1, dom.svg.tracksSvg);
  //console.log(timeDrag0Pos.x, timeDrag1Pos.x, mousePosition.x)
  //which is closest?
  if(Math.abs(timeDrag0Pos.x - mousePosition.x) < Math.abs(timeDrag1Pos.x - mousePosition.x)){
    timeLine.dragHandle = dom.svg.timeDrag0;
    timeLine.dragLine = dom.svg.timeLine0;
  }else{
    timeLine.dragHandle = dom.svg.timeDrag1;
    timeLine.dragLine = dom.svg.timeLine1;
  }
}

// --- Tracks Down, Move, Up Functions
function downHandlerTracks(evt){
  const mousePosition = getMouseTransformed(evt, dom.svg.tracksSvg);
  const distance = calculateDistance(mousePosition,trackDrag.position,true);
  if(distance<6){
    trackDrag.drag = true;
  }else if(selNote.drag){
    //const xpos = findSnap(mousePosition.x, 25, 12);
    const xpos = findSnap(mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
    selNote.start = xpos;
  }else{
    select.start = mousePosition;
    select.drag = true;
  }
}

function moveHandlerTracks(evt){
    if(timeLine.drag){
      //move line
      const mousePosition = getMouseTransformed(evt, tracksSvg);
      const xpos = findSnap(mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
      timeLine.dragHandle.setAttribute('cx', xpos);
      timeLine.dragLine.setAttribute('x', xpos);
    } else if(loopBox.drag){
      const mousePosition = getMouseTransformed(evt, tracksSvg);
      const xpos = findSnap(mousePosition.x, 100, 50);
      //console.log('loop', mousePosition)
      // Closer to start or end?
      const start = loopBox.info.start;
      const end = loopBox.info.start + loopBox.info.width;
      if((Math.abs(mousePosition.x - start) < Math.abs(mousePosition.x - end)) && loopBox.type != 'end'){
        // Resize and positionbox
        loopBox.type = 'start';
        const newWidth = loopBox.info.width - (xpos.x-start);
        loopBox.info.box.setAttribute('x', xpos.x);
        loopBox.info.box.setAttribute('width', newWidth);
        // Update loop settings
        loopBox.info.track.loop.start = (xpos/100)-1;
      }else if(loopBox.type != 'start'){ //end
        loopBox.type = 'end';
        // Resize and positionbox
        const newWidth = xpos - start;
        loopBox.info.box.setAttribute('width', newWidth);
        // Update loop settings
        loopBox.info.track.loop.end = (xpos/100)-1;
      }
      // Redraw on mouseup
    } else if(trackDrag.drag){
      const mousePosition = getMouseTransformed(evt, tracksSvg);
      //const xpos = findSnap(mousePosition.x);
      const xpos = findSnap(mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
      if(trackDrag.noteBoxId === currentNoteBox?.id){
        const startx = Number(currentNoteBox.getAttribute('x'));
        const endx = trackDrag.position.x + trackDrag.width; //to move use startx instead of trackDrag.position.x
        //const mouseSnapped = findSnap(mousePosition.x);
        const mouseSnapped = findSnap(mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
        console.log(mouseSnapped, mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
        if(trackDrag.type==='end'){
          let noteWidth = mouseSnapped - startx;
          //noteWidth = (noteWidth>20)? noteWidth:20;
          console.log(mouseSnapped, startx, noteWidth);
          currentNoteBox.setAttribute('width', noteWidth);
          //move text
          document.getElementById('text_' + trackDrag.noteBoxId).setAttribute('x', startx + (noteWidth/2));
          document.getElementById('dragEnd').setAttribute('cx', startx + noteWidth);
          //set
          currentNote.envelopeLength = noteWidth/svgData.beatScale;
          saveNodeitData();
        }else if(trackDrag.type==='start'){
          let noteWidth = endx - mouseSnapped;
          //noteWidth = (noteWidth>20)? noteWidth:20;
          currentNoteBox.setAttribute('x', mouseSnapped);
          currentNoteBox.setAttribute('width', noteWidth);
          //move text
          document.getElementById('text_' + trackDrag.noteBoxId).setAttribute('x', mouseSnapped + (noteWidth/2));
          document.getElementById('dragStart').setAttribute('cx', mouseSnapped);
          //set
          currentNote.beat = (mouseSnapped-svgData.beatScale)/svgData.beatScale;
          currentNote.envelopeLength = noteWidth/svgData.beatScale;
          saveNodeitData();
        }
      }
    }else if(select.drag) {
      const mousePosition = getMouseTransformed(evt, tracksSvg);
      const x = Math.min(mousePosition.x, select.start.x);
      const y = Math.min(mousePosition.y, select.start.y);
      const w = Math.abs(mousePosition.x - select.start.x);
      const h = Math.abs(mousePosition.y - select.start.y);
      changeSelect(x, y, w, h);
    }else if(selNote.drag) {
      const mousePosition = getMouseTransformed(evt, tracksSvg);
      //const xpos = findSnap(mousePosition.x, 25, 12);
      const xpos = findSnap(mousePosition.x, timeLine.snap.width, timeLine.snap.distance);
      const quaterBars = Math.round((xpos - selNote.start)/25);
      const move = quaterBars * 25;
      selNote.bars = quaterBars/4;

      Object.values(selNote.notes).forEach(selno =>{
        selno.r.setAttribute('x', move + selno.x);
      });
    }
}

function upHandlerTracks(evt){
  const parentId = currentNoteBox?.parentElement?.id;
  if(parentId){
    const track = currentSong.tracks.find(t => t.title === parentId);
    if(track){
      track.arrangement.sort((a, b) => parseFloat(a.beat) - parseFloat(b.beat));
      saveNodeitData();
    }
  }
  if(trackDrag.drag || loopBox.drag){
    calculateSongDuration();
    saveNodeitData();
    renderTracks();
  }else if(select.drag){
    selectNotes();
  }else if(selNote.drag){
    Object.values(selNote.notes).forEach(selno =>{
      selno.note.beat += selNote.bars;
    });
    selectNotes();
    renderTracks();
  }

  loopBox.type = null
  trackDrag.drag = false;
  loopBox.drag = false;
  select.drag = false;
  timeLine.drag = false;
  selNote.drag = false;
}

function getTimeLine(){
    const timeDrag0Pos = getTransformedElementPosition(dom.svg.timeDrag0, dom.svg.tracksSvg);
    const timeDrag1Pos = getTransformedElementPosition(dom.svg.timeDrag1, dom.svg.tracksSvg);
    if(timeDrag0Pos.x < timeDrag1Pos.x){
      timeLine.left = timeDrag0Pos.x;
      timeLine.right = timeDrag1Pos.x;
    }else{
      timeLine.left = Math.round(timeDrag1Pos.x);
      timeLine.right = Math.round(timeDrag0Pos.x);
    }
}

function updateTrack(track, modal){
  //trackIndex = index;
  currentTrack = track;
  //console.log(currentTrack);
  dom.ctrl.renameTrackInput.value = currentTrack.title;
  dom.el.trackSoundDiv.textContent = currentTrack.sounds[0].title;
  dom.ctrl.trackSoundSelect.innerHTML = dom.ctrl.soundSelect.innerHTML;
  dom.ctrl.loopCheck.checked = (currentTrack.loop.mode === 'loop')? true:false;
  dom.ctrl.loopStartInput.value = currentTrack.loop.start;
  dom.ctrl.loopEndInput.value = currentTrack.loop.end;
  dom.ctrl.loopQtyInput.value = currentTrack.loop.qty;
  dom.ctrl.trackColorInput.value = currentTrack.color;
  openModal(modal);
}

function updateTrackGain(track, trackGain){
  const gainValue = Number(trackGain.value)/100;
  track.gain = gainValue;
  if(graphNodesMix[track.id]){
    graphNodesMix[track.id].gain.setValueAtTime(gainValue, nodeData.ctx.currentTime);
  }
  saveNodeitData();
}

function muteTrack(track){
  track.mute = !track.mute;
  renderTracks();
}

function recordKeyboard(track, recordButton){
  if(keyboard.trackId != track.id){
    keyboard.recording = false; // assume false for newly selected track
  }

  keyboard.recording = !keyboard.recording;

  if(keyboard.recording){
    keyboard.arrangement = track.arrangement.sort((a, b) => a.beat - b.beat);
    const lastNote = keyboard.arrangement[keyboard.arrangement.length-1];
    keyboard.start = Math.ceil(lastNote.beat + lastNote.envelopeLength);
    keyboard.trackId = track.id;
    console.log(keyboard.start);
    recordButton.add
    track.recording = true;
    recordButton.classList.add('greyed');
    saveNodeitData();
  }else{
    recordButton.classList.remove('greyed');
    track.recording = false;
  }
}

function deleteTrack(){
  if(currentTrack){
    currentSong.tracks = currentSong.tracks.filter(t => t!=currentTrack);
    saveNodeitData();
    renderTracks();
  }
  closeModal();
}

function renameTrack(){
  if(currentTrack){
    currentTrack.title =  dom.ctrl.renameTrackInput.value;
    saveNodeitData();
    renderTracks();
  }
  closeModal();
}

function renderLoopToTrack(){
  if(currentTrack){
    //reset loop data
    currentTrack.loop = {mode:'off', start:1, end:2, qty:1};
    currentTrack.arrangement = currentTrack.virtualArrangement;
    currentTrack.arrangement.forEach(note => {
      note.id = generateId();
    });
    currentTrack.virtualArrangement = [];
    closeModal();
    saveNodeitData();
    renderTracks();
  }
}

function addTrack(){
  let trackNumber = 1;
  //find track slot
  for(let i=0; i<currentSong.tracks.length+10; i++){
    const trackMatch = currentSong.tracks.find(t => t.title === 'track' + trackNumber);
    if(trackMatch){
      trackNumber++;
    }else{
     break; //track slot found
    }
  }
  currentSong.tracks.push(new Track('track' + trackNumber));
  saveNodeitData();
  renderTracks();
}

function addNote(){
  ////console.log(currentNote);
  if(currentNote?.trackId){
    const track = currentSong.tracks.find(t => t.id === currentNote.trackId);
    const currentNotePosition = track.arrangement.findIndex(n => n.id === currentNote.id);
    //Note(title, beatDuration, envelopeLength, id)
    const timing = currentNote.beat + currentNote.envelopeLength + (beatDuration * 0.25);
    ////console.log(currentNotePosition)
    track.arrangement.splice(currentNotePosition, 0, new Note(currentNote.title, timing, (beatDuration * 0.5)));
    saveNodeitData();
    renderTracks();
  }
}

function deleteNote(){
  currentSong.tracks.forEach(track =>{
    track.arrangement = track.arrangement.filter(n => !selectedNotes.includes(n.id));
  })
  saveNodeitData();
  renderTracks();
}

function changeSemitone(semitoneSteps){
  Object.values(selNote.notes).forEach(selno =>{
    //selno.note.beat += selNote.bars;
    const index = noteListKeys.indexOf(selno.note.title);
    const newIndex = index + semitoneSteps;
    const newNote = noteListKeys[newIndex];
    if(newNote){
      selno.note.title = newNote;
      selno.note.frequency = noteList[newNote];
    }
  });
  saveAndRender();
}

function changeTrackSound(){
  if(currentTrack){
   //console.log(currentTrack.sounds[0], dom.ctrl.trackSoundSelect.value);
   const id = dom.ctrl.trackSoundSelect.value;
   if(id){
    let sound = nodeData.sounds.find(s => s.id === id);
    //console.log(sound);
    const clonedSound = cloneObject(sound, true);
    currentTrack.sounds[0] = clonedSound;
    closeModal();
    saveNodeitData();
    renderTracks();
   }
  }
}

function moveTrack(direction){
  const index = currentSong.tracks.indexOf(currentTrack);
  // Dont move up if top or down if bottom
  if(index===0 && direction==='up') return;
  if(index===currentSong.tracks.length-1 && direction==='down') return;

  const trackClone = cloneObject(currentTrack); //clone
  currentSong.tracks.splice(index, 1); //remove

  console.log(direction, currentTrack, index);

  if(direction==='up'){
     currentSong.tracks.splice(index - 1, 0, trackClone); //insert clone above
  }else if(direction==='down'){
     currentSong.tracks.splice(index + 1, 0, trackClone); //insert clone above
  }

  currentTrack = trackClone;
  saveNodeitData();
  renderTracks();
}

function updateLoop(){
  const loopCheck = dom.ctrl.loopCheck.checked;
  currentTrack.loop.mode = (loopCheck)? 'loop':'';
  currentTrack.loop.start = Number(dom.ctrl.loopStartInput.value);
  currentTrack.loop.end = Number(dom.ctrl.loopEndInput.value);
  currentTrack.loop.qty = Number(dom.ctrl.loopQtyInput.value);
  calculateSongDuration();
  saveNodeitData();
  renderTracks();
}

function fillTrack(){
  //check song length
  const songDuration = calculateSongDuration() - 2;
  const bars = Math.round(songDuration/beatDuration);
  const loopBarDuration = currentTrack.loop.end - currentTrack.loop.start;
  const qty = Math.ceil(bars/loopBarDuration);
  dom.ctrl.loopQtyInput.value = qty;
  currentTrack.loop.qty = qty;
  calculateSongDuration();
  saveNodeitData();
  renderTracks();
}

function calculateSongDuration(){
  let songDuration = 0;
  currentSong.tracks.forEach(track => {
    let arrangement = track.arrangement.sort((a, b) => a.beat - b.beat);

    if(track.loop.mode === 'loop'){
      track.virtualArrangement = createVirtualArrangement(track); //store here so you can display and render as track
      if(track.virtualArrangement.length !=0) arrangement = track.virtualArrangement;
    }
    const lastNote = arrangement[arrangement.length-1];
    const trackDuration = (lastNote.beat + lastNote.envelopeLength - 1) * beatDuration;
    if(songDuration<trackDuration) songDuration = trackDuration;
  });
  songDuration += 2; //add extra 2 seconds for start and end buffer
  return songDuration;
}

function createVirtualArrangement(track){
  const arrangement = track.arrangement;
  const virtualArrangement = [];
  let beatStart = 0;
  const loopedSegment = arrangement.filter(n => n.beat >= track.loop.start && n.beat < track.loop.end);
  for(let i=0; i<track.loop.qty; i++){
    loopedSegment.forEach(note =>{
      const newNote =  {...note}; //clone
      newNote.beat = newNote.beat + beatStart;
      newNote.id = 'virtual_' + generateId();
      virtualArrangement.push(newNote)
    });
    beatStart += (track.loop.end-track.loop.start);
  }
  return virtualArrangement;
 }

function clearGraphNodesMix(){
  console.log('clearing mix')
  Object.values(graphNodesMix).forEach(node => {
    node.disconnect();
  });
  graphNodesMix = {}; //clear
}

// --- Song Functions ---
 async function playCurrentSong(mode){

  clearGraphNodesMix();

  //start with fresh context
  nodeData.mode = mode;

  const songDuration = calculateSongDuration();
  changeModeOrDuration(songDuration);

  // Virtual note ids have been updated
  renderTracks();

  const allNotes = [];

  // Save for later
  const originalSoundId =  nodeData.currentSoundId;

  currentSong.tracks.forEach(track => {
    if(!track.mute){
      let arrangement = track.arrangement
      if(track.loop.mode === 'loop' && track.virtualArrangement.length!=0) arrangement = track.virtualArrangement;
      // Set current sound to track sound
      currentSound = track.sounds[0];
      // Play arrangement
      arrangement.forEach(note =>{
       const convertedNote = convertBeatsToSeconds(nodeData.now, note);
       playSound(convertedNote, {id:track.id, gain:track.gain});
       allNotes.push(convertedNote)
      });
    }
  });

  if(nodeData.mode==='offline' || nodeData.mode === 'render'){
    openModal('modalRendering');
  }else{
    if(nodeData.animationOn){
      highlightNotes(allNotes, 0, songDuration);
    }
  }

  if(nodeData.mode === 'offline' || nodeData.mode === 'render'){
    renderedBuffer = await nodeData.ctx.startRendering();
    promptWavDownload(renderedBuffer, currentSong.title, 'track');
    closeModal();
  }

 //reset after modifying
 updateSound(originalSoundId);
}

function bakeAllTracks(){
  renderedBufferTracks = [];
  renderTracksToBuffer(currentSong.tracks)
}

function bakeSingleTrack(index){
  console.log(index);
  renderTracksToBuffer([currentSong.tracks[index]], index);
  //currentSong.tracks[index].baked = true;

}

async function renderTracksToBuffer(tracks, index) {
  openModal('modalRendering');
  const originalSoundId =  nodeData.currentSoundId;
  const mode = nodeData.mode;
  //const allNotes = [];

  //start with fresh context
  nodeData.mode = 'render';

  //tracks.forEach((track, index) => {
  for (let i = 0; i < tracks.length; i++) {

    const track = tracks[i];

    // 1. Prepare an OfflineAudioContext sized for the track
      clearGraphNodesMix();
      const songDuration = calculateSongDuration();
      changeModeOrDuration(songDuration);

    // 2. Build your track audio graph into offlineCtx
      let arrangement = track.arrangement
      if(track.loop.mode === 'loop' && track.virtualArrangement.length!=0) arrangement = track.virtualArrangement;
      // Set current sound to track sound
      currentSound = track.sounds[0];
      // Play arrangement
      arrangement.forEach(note =>{
       const convertedNote = convertBeatsToSeconds(nodeData.now, note);
       playSound(convertedNote, {id:track.id, gain:track.gain});
       //allNotes.push(convertedNote)
      });

      // 3. Render to AudioBuffer
    const rendered = await nodeData.ctx.startRendering();

    // 4. Store it
    const id = (index)? index:i; //if index exists then is single and save to correct slot
    renderedBufferTracks[id] = {name: track.title || `Track ${index + 1}`, buffer: rendered };
  //});
  }
  // 5. Create download buttons
  createDownloadButtons();
  renderTracks();

  closeModal();
  //reset after modifying
  updateSound(originalSoundId);
  nodeData.mode = mode;
}

function trackDownload(index){
  const item = renderedBufferTracks[index];
  console.log(item.name, item.buffer);
  const wavBlob = audioBufferToWavBlob(item.buffer);
  const url = URL.createObjectURL(wavBlob);
  dom.ctrl.trackDownloadButton.href = url;
  dom.ctrl.trackDownloadButton.download = `${item.name}.wav`;
  dom.ctrl.trackDownloadButton.click();
}

function createDownloadButtons() {
 dom.el.trackDownloads.innerHTML = "";
 dom.el.trackPlayButtons.innerHTML = "";

  renderedBufferTracks.forEach((item, index) => {
    const button = document.createElement("button");
    button.textContent = `Download ${item.name}`;
    button.onclick = () => trackDownload(index);
    dom.el.trackDownloads.appendChild(button);

    const playButton = document.createElement("button");
    playButton.textContent = `Play ${item.name}`;
    playButton.onclick = () => playRenderedBuffer(renderedBufferTracks[index].buffer);
    dom.el.trackPlayButtons.appendChild(playButton);

  });
}

function addNewSong(){
  let title = dom.ctrl.newSongText.value;
  if(!title) title = "New Song"
  const track = new Track('track1');
  const song = new Song(title, 'rock', 105, [track])
  nodeData.songs.push(song);
  updateSong(song.id);
  populateSongSelect();
  saveNodeitData();
  closeModal();
}

// --- Sound Stuff
function updateSong(songId, updateTracks=true){
  // Clear rendered tracks
  renderedBufferTracks = [];
  const id = (songId)? songId:dom.ctrl.songSelect.value;
  let song = nodeData.songs.find(s => s.id === id);
  if(!song) song = nodeData.songs[0]; //get first
  currentSong = song;
  nodeData.currentSongId = song.id;
  if(updateTracks) renderTracks('updatesong');
  saveNodeitData();
}

function changeSongTitle(){
  let title = dom.ctrl.songTitleInput.value;
  if(!title) title = 'Song - ' + generateId();
  currentSong.title = title;
  populateSongSelect();
  saveNodeitData();
  closeModal();
}

function showSongDetails(){
  dom.ctrl.songTitleInput.value = currentSong.title;
  openModal('modalSongDetails');
}

function showSoundDetails(){
  dom.ctrl.soundTitleInput.value = currentSound.title;
  populateSongSoundSelect();
  openModal('modalSoundDetails');
}

function deleteSound(){
  nodeData.sounds = nodeData.sounds.filter(t => t!=currentSound);
  populateSoundSelect();
  updateSound(nodeData.sounds[0].id);
  saveNodeitData();
  closeModal();
}

function changeSoundTitle(){
  let title = dom.ctrl.soundTitleInput.value;
  if(!title) title = 'Sound - ' + generateId();
  currentSound.title = title;
  populateSoundSelect();
  saveNodeitData();
  closeModal();
}

function locateSound(selectData){
  let sound;
  if(selectData.includes('soundId')){
    const soundData = JSON.parse(selectData);
    const song = nodeData.songs.find(s => s.id === soundData.songId);
    if(song){
      const track = song.tracks.find(t => t.id === soundData.trackId);
      if(track){
        sound = track.sounds[0];
      }
    }
  }else{
    sound = nodeData.sounds.find(s => s.id === selectData);
  }
  console.log(sound)
  return sound;
}

function overwriteSound(){
  const aboveSound = locateSound(dom.ctrl.soundSelectAbove.value);
  const belowSound = locateSound(dom.ctrl.soundSelectBelow.value);

  if(aboveSound?.title && belowSound?.title){
    const clone = cloneObject(aboveSound, true);
    Object.assign(belowSound, clone);
    saveAndRender();
    closeModal();
  }else{
    showToast('Sound not found', 'error');
  }
}

function deleteSong(){
  nodeData.songs = nodeData.songs.filter(t => t!=currentSong);
  populateSongSelect();
  updateSong(nodeData.songs[0].id);
  saveNodeitData();
  closeModal();
}

function populateSongSelect(){
  dom.ctrl.songSelect.innerHTML = '';
  nodeData.songs.forEach(song => {
    const option = document.createElement('option');
    option.text = song.title;
    option.value = song.id;
    option.selected = (song.id === nodeData.currentSongId)? 'selected':'';
    dom.ctrl.songSelect.add(option);
  });
}

// --- Export or Render Song ---
function promptWavDownload(buffer, title1, title2){
  if(nodeData.mode === 'render'){
    showToast('Song rendered!', 'success');
    return;
  }
  const wavBlob = audioBufferToWavBlob(buffer);
  const url = URL.createObjectURL(wavBlob);

  // Download link
  const link = document.createElement("a");
  const id = generateId();
  link.href = url;
  link.download = `soundit_${title1}_${title2}_${id}.wav`;
  link.click();
 }

 function playRenderedBuffer(sourceBuffer) {
   console.log(sourceBuffer)
  if(!sourceBuffer){
    showToast('no buffer available', 'error');
    return;
  }
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const source = ctx.createBufferSource();
  source.buffer = sourceBuffer;
  source.connect(ctx.destination);
  source.start();
  ////console.log(`Playing rendered buffer at ${renderedBuffer.sampleRate} Hz`);
}

function playRenderedTracks(ctx, renderedBuffers) {
  // Hold sources so you can stop them later if needed
  const sources = [];

  const startTime = ctx.currentTime + 0.05; // small delay to sync safely

  renderedBuffers.forEach(buffer => {
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.connect(ctx.destination); // or your master gain node
    src.start(startTime);
    sources.push(src);
  });

  return sources; // useful if you want to stop them later
}

function audioBufferToWavBlob(buffer) {
  const numOfChan = buffer.numberOfChannels,
    length = buffer.length * numOfChan * 2 + 44,
    bufferArray = new ArrayBuffer(length),
    view = new DataView(bufferArray),
    channels = [],
    sampleRate = buffer.sampleRate;

  let pos = 0;

  function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
  function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

  // RIFF header
  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8);
  setUint32(0x45564157); // "WAVE"

  // FMT chunk
  setUint32(0x20746d66); // "fmt "
  setUint32(16);
  setUint16(1);
  setUint16(numOfChan);
  setUint32(sampleRate);
  setUint32(sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2);
  setUint16(16);

  // data chunk
  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4);

  // Write interleaved data
  for (let i = 0; i < numOfChan; i++) {
    channels.push(buffer.getChannelData(i));
  }

  let offset = 0;
  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      let sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(pos, sample, true);
      pos += 2;
    }
    offset++;
  }

  return new Blob([bufferArray], { type: "audio/wav" });
}

// ---Phrase 2 ---
function shuffle(array) {
  const copy = [...array];
  for (let i = copy.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i;
    // Destructuring assignment
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
}

function swap(array) {
  const copy = [...array];
  function randomIndex(){
    return Math.floor(Math.random() * copy.length);
  }
  const i = randomIndex();
  const j = randomIndex();
  [copy[i], copy[j]] = [copy[j], copy[i]];
  return copy;
}

function varyBySwappingOne(arr){
  let variation = swap(arr);
  for(let i=0; i<10; i++) {
    if(arr === variation){
        variation = swap(arr);
      }else{
        return variation;
    }
  }
  return variation;
}

function openPhraseModal(){
  populateRootNoteSelect();
  dom.ctrl.phraseScalesSelect.innerHTML = dom.ctrl.scalesSelect.innerHTML;
  dom.ctrl.phraseScalesSelect.value = dom.ctrl.scalesSelect.value;
  openModal('modalBuildPhrase');
}
function openDrumModal(){
  openModal('modalAddDrums');
}

function buildPhrase(){

  const rootNote = dom.ctrl.rootNoteSelect.value
  const barLen = Number(dom.ctrl.barLenInput.value);
  const noteQty = Number(dom.ctrl.noteQtyInput.value);
  const phraseQty = Number(dom.ctrl.phraseQtyInput.value);


  const m = 1/(noteQty/barLen); //(m)in len
  const a = m * 2; //average length
  const x = m * 3; //ma(x) len

  // Weight root fifth, third and seventh
  const arrangement = [];
  const phrase = [0,0,0,0,4,4,4,4,2,2,6,6];
  const duration = [m, m, m, a, a, a, a, x, x, x];
  //const duration = [0.25, 0.25, 0.25, 0.5, 0.5, 0.75, 1, 0.25, 0.25, 0.25, 0.5, 0.5, 0.75, 1];
  const scale = scales['majorScaleSemitones'];
  const rootNoteIndex = noteListKeys.indexOf(rootNote);
  const phrases = [];
  const durations = [];

  // Add additional un-weighted notes
  scale.forEach((position, index) => {
    if(phrase.indexOf(index) ===-1) phrase.push(index);
  });

  let shuffledDuration = duration;
  let shuffledPhrase = phrase;

  for(let i=0; i<10; i++) {
    shuffledPhrase = shuffle(shuffledPhrase);
    shuffledDuration = shuffle(shuffledDuration);
  }

  // Original shuffle
  phrases[0] = shuffledPhrase.splice(0, noteQty);
  durations[0] = shuffledDuration.splice(0, noteQty);

  for(let i=1; i<phraseQty; i++) {
    phrases[i] = varyBySwappingOne(phrases[i-1]);
    durations[i] = varyBySwappingOne(durations[i-1]);
  }

  let beat = 1;
  phrases.forEach((phraseSet, i) => {
    beat = Math.ceil(beat); //start new bar each phrase
    phraseSet.forEach((pos, index) => {
      const envelopeLength = durations[i][index];
      const position = scale[pos];
      const note = new Note(noteListKeys[rootNoteIndex + position], beat, envelopeLength);
      arrangement.push(note)
      beat += envelopeLength;
     console.log(note, position)
    });
  });

  console.log(arrangement)

  phraseArrangement = arrangement;

  showToast('Phrase created', 'info')
}

function playPhraseArrangement(){
  //Start with fresh context
  changeModeOrDuration();
  phraseArrangement.forEach(note =>{
    const convertedNote = convertBeatsToSeconds(nodeData.now, note);
    playSound(convertedNote);
  });
}

function createPhraseTrack(){
  currentSong.tracks.push(new Track('Phrase' + keyLastPlayed, null, phraseArrangement));
  saveAndRender();
}

function highlightClear(){
  function removeClass(className){
    document.querySelectorAll('.' + className).forEach(el => {
      el.classList.remove(className);
    });
  }
  removeClass('key-selected');
  removeClass('key-weighted');
  removeClass('key-weighted-da');
}

function addClassToKey(position, className){
  const keyId = noteListKeys[position];
  const keyboardKey = document.getElementById(keyId);
  if(keyboardKey){
    keyboardKey.classList.add(className);
  }
}

function highlightKeys(positions, title){
  highlightClear();
  const keyIndex = Number(noteListKeys.indexOf(keyLastPlayed));
  positions.forEach((position, index) => {
    const adjustedPosition = keyIndex + position;
    addClassToKey(adjustedPosition, 'key-selected');
    if((index===0 || index===2 || index===4 || index===6) && title==='scales' ){ // weight root and fifth
      addClassToKey(adjustedPosition, 'key-weighted');
      if(index===4){
        //diminished
        addClassToKey(adjustedPosition-1, 'key-weighted-da');
        //augmented
        addClassToKey(adjustedPosition+1, 'key-weighted-da');
      }
    }
  });
}

function highlightScales(){
  const selectedScale = dom.ctrl.scalesSelect.value;
  const scalePositions = scales[selectedScale];
  highlightKeys(scalePositions, 'scales')
}

function highlightChord(){
  const selectedChord = dom.ctrl.chordsSelect.value;
  const chordPositions = chords[selectedChord];
  highlightKeys(chordPositions, 'chords')
}

function chordPresetChange(){
  const preset = dom.ctrl.chordPresets.value;
  const presetList = preset.split(' ');
  if(presetList.length>0){
    keyLastPlayed = presetList[0] + dom.ctrl.octaveNumberInput.value;
    dom.ctrl.scalesSelect.value = presetList[1] + 'ScaleSemitones';
    dom.ctrl.lastKeyPlayedInput.value = keyLastPlayed;
    highlightScales();
  }
}

function changeLastPlayed(val){
  const keyIndex = Number(noteListKeys.indexOf(val));
  if(keyIndex!==-1){
    keyLastPlayed = val;
  }
}

function playSlice(buffer, startTime, endTime) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  ////console.log('playSlice')
  const source = ctx.createBufferSource();
  source.buffer = buffer;
  source.connect(ctx.destination);

  const offset = startTime;
  const duration = endTime - startTime;
  source.start(ctx.currentTime, offset, duration);
}

function playLoop(buffer, loopStart = 2.0, endTime = 4.5) {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const source = ctx.createBufferSource();
  source.buffer = buffer;
  source.connect(ctx.destination);

  source.loop = true;
  source.loopStart = loopStart;
  source.loopEnd = endTime;

  source.start(ctx.currentTime, loopStart);
  source.stop(15);
}

function playLoopButton(){
  if(renderedBuffer){
    getTimeLine();
    const startTime = ((timeLine.left-100)/100) * beatDuration;
    const endTime = ((timeLine.right-100)/100) * beatDuration;
    playLoop(renderedBuffer, startTime, endTime);
  }else{
    showToast('Render track first', 'info');
  }
}

function playSliceButton(){
  if(renderedBuffer){
    getTimeLine();
    const startTime = ((timeLine.left-100)/100) * beatDuration;
    const endTime = ((timeLine.right-100)/100) * beatDuration;
    playSlice(renderedBuffer, startTime, endTime);
  }else{
   showToast('Render track first', 'info');
  }
}

function populateScalesSelect(){
  dom.ctrl.scalesSelect.innerHTML = "";
  Object.keys(scales).forEach(key => {
    const option = document.createElement('option');
    option.text = key.replace('Semitones', '').replace('Scale', '');
    option.value = key;
    //option.selected = (song.id === nodeData.currentSongId)? 'selected':'';
    dom.ctrl.scalesSelect.add(option);
  });
}

function populateChordsSelect(){
  dom.ctrl.chordsSelect.innerHTML = "";
  Object.keys(chords).forEach(key => {
    const option = document.createElement('option');
    option.text = key.replace('Semitones', '').replace('Scale', '');
    option.value = key;
    //option.selected = (song.id === nodeData.currentSongId)? 'selected':'';
    dom.ctrl.chordsSelect.add(option);
  });
}

// --- Render ---
function renderTracks(from){
  //console.log('rendering tracks', from);
  // Clear all dom notes
  dom.notes = {};
  dom.svg.trackContainer.innerHTML = '';
  let trackNumber = 1;
  let yAdjust = 10.5;
  const songDuration = calculateSongDuration();
  const trackControlsWidth = 200;
  const trackWidth = (Math.ceil(songDuration/beatDuration) * 100) - 200;
  const colors = [];

  currentSong.tracks.forEach((track, index) => {

    //currentSongSounds.push(track.sounds[0])
    const colorIndex = index % 8;
    const className = `track-container track-${colorIndex}`;
    if(!track.color) track.color = trackColors[colorIndex];
    colors.push(track.color);
    const trackContainer = createGroup(track.title, yAdjust, dom.svg.trackContainer, className);
    trackContainer.dataset.id = track.id;
    createRect2(null, {x:10, y:0}, trackWidth + trackControlsWidth - 10, null, null, null, trackContainer, 'track-outline');
    createRect2(null, {x:trackControlsWidth, y:0}, trackWidth, null, null, null, trackContainer, 'track-body');

    if(track.loop.mode === 'loop'){
      let loopStart = 100 + (100 * track.loop.start);
      const loopWidth = (svgData.beatScale * (track.loop.end-track.loop.start));
      const loopBox = createRect2(null, {x:loopStart, y:0}, loopWidth, null, null, null, trackContainer, 'loop-track');
      loopBox.onmousedown = () => loopSelect(loopBox, track, loopStart, loopWidth);
    }
    const trackSound = track.sounds[0];
    //const soundTitle = trackSound.title // .map(({ title }) => title).join(' | ');

    //Arrangements
    track.virtualArrangement.forEach(note =>{
      const noteWidth = (svgData.beatScale * note.envelopeLength);
      const xPos = (svgData.beatScale * note.beat) + svgData.beatScale;
      createNoteBoxVirtual({x:xPos, y:20}, noteWidth, note, trackContainer, track.id);
    });

    track.arrangement.forEach(note =>{
      const noteWidth = (svgData.beatScale * note.envelopeLength);
      const xPos = (svgData.beatScale * note.beat) + svgData.beatScale;
      createNoteBox({x:xPos, y:20}, noteWidth, note, trackContainer, track.id);
    });

    //Track controls
    const trackTitle = createDiv('track-title box-color', track.title);
    trackTitle.onclick = () => updateTrack(track, 'modalTrackOptions');

    const soundButton = createButton('box-color sound-button', trackSound.title);
    soundButton.onclick = () => updateSound(trackSound.id);

    const loopButton = createButton('box-color', 'L');
    loopButton.onclick = () => updateTrack(track, 'modalLoopSettings');

    const deleteButton = createButton('box-color', 'D');
    deleteButton.onclick = () => updateTrack(track, 'modalDeleteTrack');

    const muteClassName = (track.mute)? 'box-color greyed':'box-color';
    const muteButton = createButton(muteClassName, 'M');
    muteButton.onclick = () => muteTrack(track);

    //New session so keyboard.recording will equal false on refresh/start
    const recordClassName = (track.recording && keyboard.recording)? 'box-color greyed':'box-color';
    const recordButton = createButton(recordClassName, 'R');
    recordButton.id = generateId();
    recordButton.onclick = () => recordKeyboard(track, recordButton);

    //Bake button
    //console.log(renderedBufferTracks[index], renderedBufferTracks[index])
    const bakeClassName = (renderedBufferTracks[index])? 'box-color greyed':'box-color';
    const bakeButton = createButton(bakeClassName, 'B');
    bakeButton.onclick = () => bakeSingleTrack(index);

    const trackGainContainer = createDiv('track-gain-container');
    const trackGain = document.createElement('input');
    trackGain.type = 'range';
    trackGain.value = Number(track.gain) * 100;
    trackGain.min = 0;
    trackGain.max = 100;
    trackGain.oninput = () => updateTrackGain(track, trackGain);
    trackGainContainer.appendChild(trackGain);

    const htmlElements = createDiv(`controls-container track${colorIndex}`);
    htmlElements.appendChild(trackTitle);
    htmlElements.appendChild(soundButton);
    htmlElements.appendChild(loopButton);
    htmlElements.appendChild(deleteButton);
    htmlElements.appendChild(muteButton);
    htmlElements.appendChild(recordButton);
    htmlElements.appendChild(bakeButton);
    htmlElements.appendChild(trackGainContainer);

    createForeignObject('t_' + track.id, {x:0, y:0}, trackControlsWidth - 5, 70, null, htmlElements, trackContainer, 'track-controls');

    trackNumber++;
    yAdjust += 80;
  });

  //track.color
  updateLinearGradients(colors);

  // Why do this here?
  tracksSvg.setAttribute('height', tracksHeight());
  tracksSvg.setAttribute('viewBox', `0 0 1800 ${tracksHeight()}`);
  svgData.width = Number(tracksSvg.getAttribute("width"));
  svgData.height = Number(tracksSvg.getAttribute("height"));

  // Set Zoom
  const resolution = (currentSong.resolution)? currentSong.resolution:'4';
  const zoom = (currentSong.zoom)? currentSong.zoom*100:100;
  const pan = (currentSong.pan)? currentSong.pan:0;
  const snap = (currentSong.snap)? currentSong.snap:true;

  dom.ctrl.resolutionSelect.value = resolution;
  dom.ctrl.zoomRange.value = zoom;
  dom.ctrl.panLeftRange.value = pan;
  dom.ctrl.snapCheckbox.checked = snap;
  changeZoom();
}

function renderKeyboardKeys(){
  const keys = noteListKeys;
  keys.forEach((key, index) => {
    const previousKey = keys[index-1];
    let additionalClassNew = '';

    if(previousKey?.includes('#')){
      additionalClassNew = ' lh-minor'
    }

    let keyText = key;
    if(key.includes('#')){
      const firstLetter = key.charAt(0);
      const lastLetter = key.slice(-1);
      keyText = `${keyText}\r\n${lookupFlat[firstLetter]}${lastLetter}`;
      keyText = keyText.replace(/\d+/g, '');
    }

    const button = document.createElement('button');
    button.className = (key.includes('#'))? 'key-button-minor':'key-button-major' + additionalClassNew;
    button.textContent = keyText;
    button.onmousedown = () => playKey(event, key);
    button.onmouseup = () => stopKey(event, key);
    button.id = key;
    dom.el.keyboard.appendChild(button);
  })
}

function setToContext(){
  if(nodeData.mode !== 'context'){
    nodeData.mode = 'context';
    changeModeOrDuration();
  }
}

let keyId = null;

function playKey(event, key){
  setToContext();
  keyLastPlayed = key;
  dom.ctrl.lastKeyPlayedInput.value = key;
  ensureAudioContext();
  keyId = playSound({title:key, time:nodeData.ctx.currentTime, duration:3});

  if(event.shiftKey && currentNote?.id){
    currentNote.title = key;
    saveNodeitData();
    renderTracks();
  }

  if(keyboard.recording){
    keyboard.noteStart = nodeData.ctx.currentTime
  }
}

function stopKey(){
  const now = nodeData.ctx.currentTime;
  const release = 0.5; // length of fade-out
  const endTime = now + release;
  const id = keyId;
  let oscillatorStopped = false;
  Object.keys(graphNodes).forEach(key =>{
    const node = graphNodes[key];
    if(node.constructor.name === 'OscillatorNode' && !oscillatorStopped){
      node.stop(endTime + 0.05);
        node.onended = () => {
        stopSound(id);
       // console.log('stopping')
      }
      oscillatorStopped = true; //only one required
    }else if(node.constructor.name === 'GainNode'){
      const current = node.gain.value;

      // Reset automation, and set starting point
      node.gain.cancelScheduledValues(now);
      node.gain.setValueAtTime(current, now);
      node.gain.exponentialRampToValueAtTime(0.001, endTime);
    }
  });

  if(keyboard.recording){
    console.log(keyboard)
    const beat = keyboard.start;
    const envelopeLength = Math.ceil((now - keyboard.noteStart)/(beatDuration/4)) * 0.25;
    const note = new Note(keyLastPlayed, beat, envelopeLength);
    keyboard.arrangement.push(note);
    keyboard.start += envelopeLength;
    saveNodeitData();
    renderTracks();
  }
}

// --- Periodic Waves ---
const realHarmonics = document.getElementById('realHarmonics');
const imagHarmonics = document.getElementById('imagHarmonics');
let wave;
let numHarmonics = 8;
let real = new Float32Array(numHarmonics + 1);
let imag = new Float32Array(numHarmonics + 1);
let periodicWaveData = {
  ctx:new AudioContext(),
  osc:null,
  currentNode:null,
  }
periodicWaveData.osc = periodicWaveData.ctx.createOscillator();

const periodicWavePath = document.getElementById('periodicWavePath');
const periodicSvg = document.getElementById('periodicSvg');
const periodicWaveSelect = document.getElementById('periodicWaveSelect');
const display = {pad:{x:70, y:50}, dimensions:{x:340, y:200}, renderGraph:true};

const periodicWavePresetValues = Object.values(periodicWavePresets);
//console.log(periodicWavePresetValues)
periodicWaveSelect.innerHTML = '';
periodicWavePresetValues.forEach(presetName => {
  const option = document.createElement('option')
  option.value = presetName.title;
  option.text = presetName.title;
  periodicWaveSelect.add(option);
})

function usePeriodicPreset(presetTitle){
  const presetInstrument = periodicWavePresets.find(p => p.title === presetTitle);
  real = new Float32Array(presetInstrument.real);
  imag = new Float32Array(presetInstrument.imaginary);

  const wave = periodicWaveData.ctx.createPeriodicWave(
    real,
    imag,
    { disableNormalization: true }
  );

  numHarmonics = real.length-1;
  updateControls();
  updateWave();
  periodicWaveData.osc.setPeriodicWave(wave);
}

function startTestSound(){
  const time = periodicWaveData.ctx.currentTime;
  updateWave();
  const gainValue = 0.1;
  const duration = 6;

  const gain = periodicWaveData.ctx.createGain();
  gain.gain.value = gainValue;
  gain.gain.linearRampToValueAtTime(gainValue, time + (duration*0.75)); //sustain till 0.75 the way through
  gain.gain.linearRampToValueAtTime(0.001, time + duration);
  periodicWaveData.osc.connect(gain);
  gain.connect(periodicWaveData.ctx.destination);

  periodicWaveData.osc.start(time);
  periodicWaveData.osc.stop(time + duration);
}

function updateWave() {
  let line;
  if (wave) wave = null;
  wave = periodicWaveData.ctx.createPeriodicWave(real, imag, { disableNormalization: true });
  periodicWaveData.osc.setPeriodicWave(wave);

  if(periodicWaveData.currentNode){
    periodicWaveData.currentNode.parameters.real.value =  [...real];
    periodicWaveData.currentNode.parameters.imaginary.value = [...imag];
    line = document.getElementById('periodicwaveLine_' + periodicWaveData.currentNode.id);
    saveNodeitData();
  }

  drawWaveform(line);
}

function setUpPeriodicWave(node, openMod){
  updateControls();
  periodicWaveData.currentNode = node;
  real = new Float32Array(node.parameters.real.value);
  imag = new Float32Array(node.parameters.imaginary.value);
  updateWave()
  if(openMod) openModal('modalPeriodicWave');
}

function drawWaveform(line) {
  const svgwidth = display.dimensions.x;
  const svgheight = display.dimensions.y;
  //console.log(real, imag);
  let wavePath = '';
  for (let x = 0; x < svgwidth; x++) {
    const t = x / svgwidth;
    let y = 0;
    for (let n = 1; n <= numHarmonics; n++) {
      y += real[n] * Math.cos(2 * Math.PI * n * t) + imag[n] * Math.sin(2 * Math.PI * n * t);
    }
    const py = (display.dimensions.y/2) - y * 40;

    wavePath += (x === 0)? `M${x + display.pad.x} ${py + display.pad.y}`:` L${x + display.pad.x} ${py + display.pad.y}`;
  }
  periodicWavePath.setAttribute('d',wavePath);
  if(line) line.setAttribute('d',wavePath);
}

function updateControls(){
  realHarmonics.innerHTML = '';
  imagHarmonics.innerHTML = '';
  const realTitle = document.createElement('div');
  realTitle.className = 'harmonic-title';
  realTitle.textContent = 'Real';
  const imagTitle = document.createElement('div');
  imagTitle.className = 'harmonic-title';
  imagTitle.textContent = 'Imag';
  realHarmonics.appendChild(realTitle);
  imagHarmonics.appendChild(imagTitle);

  for (let n = 1; n <= numHarmonics; n++) {
    const r = document.createElement('input');
    const i = document.createElement('input');
    r.type = i.type = 'number';
    r.step = i.step = '0.1';
    r.value = niceNum(real[n]);
    r.id = 'real_' + (n-1);
    i.id = 'imag_' + (n-1);
    i.value = niceNum(imag[n]);
    r.oninput = () => { real[n] = parseFloat(r.value); updateWave(); };
    i.oninput = () => { imag[n] = parseFloat(i.value); updateWave(); };
    const realDiv = document.createElement('div');
    const imagDiv = document.createElement('div');
    realDiv.appendChild(r);
    imagDiv.appendChild(i);
    realHarmonics.appendChild(realDiv);
    imagHarmonics.appendChild(imagDiv);
  }
}

function pulsePeriodicWave(ctx, duty = 0.25, harmonics = 32) {
  const realArr = [];
  const imagArr = [];

  const real = new Float32Array(harmonics + 1);
  const imag = new Float32Array(harmonics + 1);

  for (let n = 1; n <= harmonics; n++) {
    const a = (2 / (n * Math.PI)) * Math.sin(n * Math.PI * duty);
    real[n] = a * Math.cos(n * Math.PI * (1 - duty));
    imag[n] = a * Math.sin(n * Math.PI * (1 - duty));
    realArr[n] = niceNum(a * Math.cos(n * Math.PI * (1 - duty)));
    imagArr[n] = niceNum(a * Math.sin(n * Math.PI * (1 - duty)));
  }

  //return ctx.createPeriodicWave(real, imag, { disableNormalization: true });
  return {real:realArr, imaginary:imagArr}
}

// --- Create Multi Voice Unison ---
function unison(baseFreq, numVoices, shapeType, curve, oscillator1, oscillator2){
  const detuneAmount = 0.015; // 1.5% range
  const gainValue = 0.7/numVoices;
  const voices = [];
  let shaped;

  // Generate voices
  for (let i = 0; i < numVoices; i++) {
    const norm = i / (numVoices - 1);
    const linear = (norm - 0.5) * 2; // -1 to +1
    const panValue = (i / (numVoices - 1)) * 2 - 1;

    if(shapeType === 'power'){
      // Serum-style exponential compression
      shaped = Math.sign(linear) * Math.pow(Math.abs(linear), curve);
    }else if(shapeType === 'tanh'){
      // Smooth S-curve: natural spacing, soft edges
      shaped = Math.tanh(linear * gainValue);
    }else if(shapeType === 'sinh'){
      // More aggressive spread near extremes
      shaped = Math.sinh(linear * gainValue) / Math.sinh(gainValue);
      // Simple non-linear easing (lighter center clustering)
    }else if(shapeType === 'cubic'){
      shaped = linear ** 3;
    }else{
      shaped = linear;
    }

    const detune = shaped * detuneAmount;
    const frequency = baseFreq * (1 + detune);
    const oscillatorType = (i % 2 === 0)? oscillator2:oscillator1;
    const phaseOffset = Math.random() / baseFreq; // up to one full cycle offset

    voices.push({frequency, gainValue, panValue, phaseOffset, oscillatorType});

  }
  return voices
}

function generateDrumPattern(genre = "rock", bars = 2, stepsPerBeat = 4) {
  const totalBeats = 4 * bars;
  const notes = [];

  const grooves = {
    rock: {
      kick:  [1,0,0,0, 0.8,0,0,0, 1,0,0,0, 0.8,0,0,0],
      snare: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
      hat:   [0.8,0.1,0.8,0.1, 0.8,0.1,0.8,0.1, 0.8,0.1,0.8,0.1, 0.8,0.1,0.8,0.1]
    },
    funk: {
      kick:  [1,0,0.3,0, 0.2,0,0.8,0.1, 1,0,0.3,0, 0.2,0,0.8,0.1],
      snare: [0,0,0.9,0.1, 0,0.2,1,0.2, 0,0,0.9,0.1, 0,0.2,1,0.3],
      hat:   [0.8,0.2,0.8,0.2, 0.8,0.2,0.8,0.2, 0.8,0.2,0.8,0.2, 0.8,0.2,0.8,0.2],
      ohat:  [0,0,0,0, 0,0,0,0, 0,0.1,0,0, 0,0,0.3,0]
    },
    house: {
      kick:  Array(16).fill(0).map((_,i)=> i%4===0?1:0),
      snare: Array(16).fill(0).map((_,i)=> i%8===4?0.9:0),
      hat:   Array(16).fill(0.7),
      ohat:  [0,0,0,0.3, 0,0,0,0.3, 0,0,0,0.3, 0,0,0,0.3]
    },
    breakbeat: {
      kick:  [1,0.1,0.4,0, 0.8,0.1,0.2,0, 1,0,0.4,0.2, 0.6,0.1,0.3,0.1],
      snare: [0,0,0.9,0, 0,0.1,1,0, 0,0.1,0.9,0.1, 0,0,1,0.2],
      hat:   [0.7,0.2,0.7,0.2, 0.7,0.2,0.7,0.2, 0.7,0.2,0.7,0.2, 0.7,0.2,0.7,0.2]
    }
  };

  const pattern = grooves[genre] || grooves.rock;
  const steps = pattern.kick.length;

  for (let i = 0; i < totalBeats * stepsPerBeat; i++) {
    const beat = i / stepsPerBeat + 1;
    for (const drum in pattern) {
      const prob = pattern[drum][i % steps];
      if (Math.random() < prob) {
        notes.push({
          title: drum,
          beat: beat + (Math.random() - 0.5) * 0.02, // human feel
          envelopeLength: 0.25
        });
      }
    }
  }
  return notes;
}

//1. Two-Bar Rock Groove (with a small fill)
//A steady backbone for pop or rock  bar two adds a snare flourish before looping.
const drumPatterns = {
"rock-grove":[
  // Bar 1
  {"title": "kick", "beat": 1, "envelopeLength": 0.5},
  {"title": "snare", "beat": 2, "envelopeLength": 0.5},
  {"title": "kick", "beat": 3, "envelopeLength": 0.5},
  {"title": "snare", "beat": 4, "envelopeLength": 0.5},
  // Hats
  {"title": "hat", "beat": 1, "envelopeLength": 0.25},
  {"title": "hat", "beat": 1.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 4, "envelopeLength": 0.25},
  {"title": "hat", "beat": 4.5, "envelopeLength": 0.25},
  // Bar 2 (beats 58)
  {"title": "kick", "beat": 5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 6, "envelopeLength": 0.5},
  {"title": "kick", "beat": 7, "envelopeLength": 0.5},
  {"title": "snare", "beat": 8, "envelopeLength": 0.5},
  // Hats continued
  {"title": "hat", "beat": 5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 5.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 6, "envelopeLength": 0.25},
  {"title": "hat", "beat": 6.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 7, "envelopeLength": 0.25},
  {"title": "hat", "beat": 7.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 8, "envelopeLength": 0.25},
  {"title": "hat", "beat": 8.5, "envelopeLength": 0.25},
  // Snare fill
  {"title": "snare", "beat": 7.75, "envelopeLength": 0.25},
  {"title": "snare", "beat": 7.875, "envelopeLength": 0.25}
],
//2. Funk Groove (ghost notes + syncopation)
//This one breathes. Slight offbeat kick, ghost snares, and a funky open hat before looping.
"funk-grove":[
  {"title": "kick", "beat": 1, "envelopeLength": 0.5},
  {"title": "snare", "beat": 2, "envelopeLength": 0.5},
  {"title": "kick", "beat": 2.75, "envelopeLength": 0.5},
  {"title": "snare", "beat": 3.75, "envelopeLength": 0.25},
  {"title": "kick", "beat": 4, "envelopeLength": 0.5},

  {"title": "hat", "beat": 1, "envelopeLength": 0.25},
  {"title": "hat", "beat": 1.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 4, "envelopeLength": 0.25},
  {"title": "ohat", "beat": 3.75, "envelopeLength": 0.5},
  // Bar 2
  {"title": "kick", "beat": 5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 6, "envelopeLength": 0.5},
  {"title": "kick", "beat": 6.75, "envelopeLength": 0.5},
  {"title": "snare", "beat": 7.75, "envelopeLength": 0.25},
  {"title": "kick", "beat": 8, "envelopeLength": 0.5},
  {"title": "snare", "beat": 8.75, "envelopeLength": 0.25},
  {"title": "ohat", "beat": 7.75, "envelopeLength": 0.5},
  {"title": "hat", "beat": 5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 5.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 6, "envelopeLength": 0.25},
  {"title": "hat", "beat": 6.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 7, "envelopeLength": 0.25},
  {"title": "hat", "beat": 7.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 8, "envelopeLength": 0.25},
  {"title": "hat", "beat": 8.5, "envelopeLength": 0.25}
],
//Breakbeat/Jungle Fast and syncopated  you can halve the playback rate to use it as a slower break.
"breakbeat-jungle":[
  {"title": "kick", "beat": 1, "envelopeLength": 0.5},
  {"title": "snare", "beat": 1.75, "envelopeLength": 0.5},
  {"title": "kick", "beat": 2.5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 3, "envelopeLength": 0.5},
  {"title": "kick", "beat": 3.5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 4, "envelopeLength": 0.5},
  {"title": "hat", "beat": 1, "envelopeLength": 0.25},
  {"title": "hat", "beat": 1.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2, "envelopeLength": 0.25},
  {"title": "hat", "beat": 2.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3, "envelopeLength": 0.25},
  {"title": "hat", "beat": 3.5, "envelopeLength": 0.25},
  {"title": "hat", "beat": 4, "envelopeLength": 0.25},
  {"title": "hat", "beat": 4.5, "envelopeLength": 0.25},
  // Bar 2 (variation)
  {"title": "kick", "beat": 5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 5.75, "envelopeLength": 0.5},
  {"title": "kick", "beat": 6.25, "envelopeLength": 0.5},
  {"title": "snare", "beat": 7, "envelopeLength": 0.5},
  {"title": "kick", "beat": 7.5, "envelopeLength": 0.5},
  {"title": "snare", "beat": 8, "envelopeLength": 0.5},
  {"title": "snare", "beat": 8.75, "envelopeLength": 0.25}
],
}

function createDrumTracks(){
  let drums;
  const drumNotes = {kick:'d2',snare:'d1', hat:'d4', ohat:'d5'};
  const drumSounds= {kick:'Kick Drum',snare:'Snare Drum', hat:'Hi Hat', ohat:'Hi Hat'};
  const genre = dom.ctrl.drumGenreSelect.value;
  const drumCollection = {}

  if(genre.includes('-')){
    drums = drumPatterns[genre];
  }else{
    const bars = 2;
    const stepsPerBeat = 4;
    //console.log(genre);
    drums = generateDrumPattern(genre, bars, stepsPerBeat);
  }

  drums.forEach(beat => {
    const title = beat.title;
    if(!drumCollection[title]) drumCollection[title] = [];
    beat.title = drumNotes[beat.title] || 'a4';
    beat.id = generateId();
    drumCollection[title].push(beat);
    //n note
  });
  //sort
  Object.keys(drumCollection).forEach(key =>{
   const drum = drumCollection[key];
   drum.sort((a, b) => a.beat - b.beat);

   const sound = nodeData.sounds.find(s => s.title === drumSounds[key]);

   //console.log(sound)
   if(sound){
     currentSong.tracks.push(new Track(key, [cloneObject(sound, true)], drum, {mode:'loop', start:1, end:2, qty:8}, 0.5,));
     saveNodeitData();
     renderTracks();
   }

  });
}

function findKey(index){
 index = Number(index)-1;
 const selectedScale = dom.ctrl.scalesSelect.value;
 const scalePositions = scales[selectedScale];
 const scaleValue = scalePositions[index % scalePositions.length];
 const keyIndex = noteListKeys.indexOf(keyLastPlayed);
 return noteListKeys[keyIndex + scaleValue];
}

function keyUpHandler(event){
  const key = event.key;
  const playedKey = findKey(key);
  const keyButton = document.getElementById(playedKey);
  if(keyButton) keyButton.classList.remove('key-played');
  activeKeys.delete(key);
}

function keyDownHandler(event){
  let key = event.key;
  if (activeKeys.has(key)){
    return; // already playing this key
  }
  activeKeys.add(key);
  const numberMatch = key.match(/[0-9]/);
  if(numberMatch){
    if(key == 0) key = 10; //match keyboard keys
    const playedKey = findKey(key);
    ensureAudioContext();
    //playSound({title:playedKey, time:nodeData.ctx.currentTime, duration:1});
    document.getElementById(playedKey).classList.add('key-played');
  }else if (key === "Delete") {
    console.log('delete');
  }
}

// Legacy Remove
function removeLegacy(){
  nodeData.songs.forEach(song => {
    //console.log(song.title);
    song.tracks.forEach(track => {
      //console.log(track.sounds[0]);
      track.sounds[0].nodes.forEach((node,index) => {
        if(node.type === 'sound'){
          console.log(song.title, track.sounds[0].title, node, index);
        }

      });
    });
  });
  saveNodeitData();
}

function initSound(){
  // Shorten to loop arr
  updateLinearGradients(trackColors);

  dom.svg.timeDrag0.addEventListener('mousedown', downHandlerTime);
  dom.svg.timeDrag1.addEventListener('mousedown', downHandlerTime);

  renderSoundReady = true;
  renderSound();

  renderKeyboardKeys();
  renderTracks();
  populateSongSelect();
  populateScalesSelect();
  populateChordsSelect();

  dom.svg.tracksSvg.addEventListener("mousedown", downHandlerTracks, false);
  dom.svg.tracksSvg.addEventListener("mousemove", moveHandlerTracks, false);
  dom.svg.tracksSvg.addEventListener("mouseup", upHandlerTracks, false);

  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);

  dom.ctrl.loopCheck?.addEventListener('input', updateLoop);
  dom.ctrl.loopStartInput?.addEventListener('input', updateLoop);
  dom.ctrl.loopEndInput?.addEventListener('input', updateLoop);
  dom.ctrl.loopQtyInput?.addEventListener('input', updateLoop);
  changeModeOrDuration();
  populateRootNoteSelect();
}

function checkSave(){
  const daysTillReminder = 1;
  const today = formatDate(new Date());
  const difference = dateDifferenceInDays(today, nodeData.lastSaved);
  console.log(difference, today, nodeData.lastSaved)
  if(difference>daysTillReminder){
    dom.el.lastSavedText.textContent = `It has been ${difference} days since you last saved. Browser data can easily be wiped.`;
    openModal('modalSave');
  }
}

function init(){
  initDomReferences();
  loadNodeitData();
  populateNodeSelect();
  removeLegacy();
  checkSave()
}
init();
</script>

<svg xmlns="http://www.w3.org/2000/svg" class="planit-hidden">
    <symbol id="side-panel" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
     <rect x="2" y="2" width="20" height="20" rx="4" ry="4"></rect>
     <path d="m15 2v20"></path>
    </symbol>
    <symbol id="down-arrow" viewBox="0 0 24 24">
      <path d="m12 22.9c-5.06 0.0521-10.1-0.763-11.2-2.49-2.04-3.45 6.92-19.3 10.9-19.4 4.01-0.0412 13.3 15.7 11.3 19.2-0.984 1.74-6.04 2.66-11.1 2.72z" />
    </symbol>
    <symbol id="up-arrow" viewBox="0 0 24 24">
      <path d="m12 1.06c-5.06-0.0521-10.1 0.763-11.2 2.49-2.04 3.45 6.92 19.3 10.9 19.4 4.01 0.0412 13.3-15.7 11.3-19.2-0.984-1.74-6.04-2.66-11.1-2.72z" />
    </symbol>
  </svg>
</body>
</html>
